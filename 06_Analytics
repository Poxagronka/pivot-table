/**
 * Analytics Functions - Multi Project Support
 * Contains all analytical calculations and metrics
 * –ò–°–ü–†–ê–í–õ–ï–ù–û: WoW –º–µ—Ç—Ä–∏–∫–∏ —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞—é—Ç –ø–æ campaignId –≤–º–µ—Å—Ç–æ sourceApp
 * –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –ø–æ—Ä–æ–≥–æ–≤ —Å —ç–º–æ–¥–∑–∏
 */

/**
 * Calculate Week-over-Week metrics per campaign and per app
 * –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –¢–µ–ø–µ—Ä—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∫–∞–∂–¥—É—é –∫–∞–º–ø–∞–Ω–∏—é –ø–æ campaignId
 */
function calculateWoWMetrics(appData) {
  if (!appData || typeof appData !== 'object') {
    console.error('Invalid appData provided to calculateWoWMetrics');
    return { campaignWoW: {}, appWeekWoW: {} };
  }

  try {
    const campaignData = {};
    const appWeekData = {};

    // Aggregate raw data
    Object.values(appData).forEach(app => {
      appWeekData[app.appName] = {};
      Object.values(app.weeks).forEach(week => {
        const spend = week.campaigns.reduce((s, c) => s + c.spend, 0);
        const profit = week.campaigns.reduce((s, c) => s + c.eProfitForecast, 0);
        appWeekData[app.appName][week.weekStart] = { weekStart: week.weekStart, spend, profit };

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ campaignId –≤–º–µ—Å—Ç–æ sourceApp
        week.campaigns.forEach(c => {
          if (c.campaignId) {
            const key = `${c.campaignId}_${week.weekStart}`;
            campaignData[key] = {
              campaignId: c.campaignId,
              campaignName: c.campaignName,
              sourceApp: c.sourceApp,
              weekStart: week.weekStart,
              spend: c.spend,
              eRoasForecast: c.eRoasForecast,
              eProfitForecast: c.eProfitForecast,
              installs: c.installs,
              cpi: c.cpi,
              roas: c.roas,
              ipm: c.ipm,
              eArpuForecast: c.eArpuForecast
            };
          }
        });
      });
    });

    // Compute campaign WoW - –ò–°–ü–†–ê–í–õ–ï–ù–û: –¢–µ–ø–µ—Ä—å –ø–æ campaignId
    const campaigns = {};
    Object.values(campaignData).forEach(d => {
      if (!campaigns[d.campaignId]) campaigns[d.campaignId] = [];
      campaigns[d.campaignId].push(d);
    });

    const campaignWoW = {};
    Object.keys(campaigns).forEach(campaignId => {
      campaigns[campaignId].sort((a, b) => new Date(a.weekStart) - new Date(b.weekStart));
      campaigns[campaignId].forEach((curr, i) => {
        const key = `${campaignId}_${curr.weekStart}`;
        campaignWoW[key] = { 
          spendChangePercent: 0, 
          eProfitChangePercent: 0, 
          growthStatus: 'First Week' 
        };
        
        if (i > 0) {
          const prev = campaigns[campaignId][i - 1];
          const spendPct = prev.spend ? ((curr.spend - prev.spend) / Math.abs(prev.spend)) * 100 : 0;
          const profitPct = prev.eProfitForecast ? ((curr.eProfitForecast - prev.eProfitForecast) / Math.abs(prev.eProfitForecast)) * 100 : 0;
          
          const status = calculateGrowthStatus(prev, curr, spendPct, profitPct);
          campaignWoW[key] = { 
            spendChangePercent: spendPct, 
            eProfitChangePercent: profitPct, 
            growthStatus: status 
          };
        }
      });
    });

    // Compute app-level WoW (–æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    const appWeekWoW = {};
    Object.keys(appWeekData).forEach(appName => {
      const weeks = Object.values(appWeekData[appName]).sort((a, b) => new Date(a.weekStart) - new Date(b.weekStart));
      weeks.forEach((curr, i) => {
        const key = `${appName}_${curr.weekStart}`;
        appWeekWoW[key] = { 
          spendChangePercent: 0, 
          eProfitChangePercent: 0, 
          growthStatus: 'First Week' 
        };
        
        if (i > 0) {
          const prev = weeks[i - 1];
          const spendPct = prev.spend ? ((curr.spend - prev.spend) / Math.abs(prev.spend)) * 100 : 0;
          const profitPct = prev.profit ? ((curr.profit - prev.profit) / Math.abs(prev.profit)) * 100 : 0;
          
          const status = calculateGrowthStatus(prev, curr, spendPct, profitPct, 'profit');
          appWeekWoW[key] = { 
            spendChangePercent: spendPct, 
            eProfitChangePercent: profitPct, 
            growthStatus: status 
          };
        }
      });
    });

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –í–æ–∑–≤—Ä–∞—â–∞–µ–º campaignWoW –≤–º–µ—Å—Ç–æ sourceAppWoW
    return { campaignWoW, appWeekWoW };
  } catch (error) {
    console.error('Error calculating WoW metrics:', error);
    return { campaignWoW: {}, appWeekWoW: {} };
  }
}

/**
 * Calculate growth status based on spend and profit changes
 * –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –ø–æ—Ä–æ–≥–æ–≤ —Å —ç–º–æ–¥–∑–∏
 */
function calculateGrowthStatus(prev, curr, spendPct, profitPct, profitField = 'eProfitForecast') {
  const prevProfit = profitField === 'profit' ? prev.profit : prev.eProfitForecast;
  const currProfit = profitField === 'profit' ? curr.profit : curr.eProfitForecast;
  
  // –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–µ –ø–æ—Ä–æ–≥–∏ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
  const thresholds = {
    healthyGrowth: { minSpendChange: 10, minProfitChange: 5 },
    efficiencyImprovement: { maxSpendDecline: -5, minProfitGrowth: 8 },
    inefficientGrowth: { minSpendChange: 0, maxProfitChange: -8 },
    decliningEfficiency: { minSpendStable: -2, maxSpendGrowth: 10, maxProfitDecline: -4, minProfitDecline: -7 },
    scalingDown: { 
      maxSpendChange: -15,
      efficient: { minProfitChange: 0 },
      moderate: { maxProfitDecline: -10, minProfitDecline: -1 },
      problematic: { maxProfitDecline: -15 }
    },
    moderateGrowthSpend: 3,
    moderateGrowthProfit: 2,
    minimalGrowth: { maxSpendChange: 2, maxProfitChange: 1 },
    moderateDecline: { 
      maxSpendDecline: -3, 
      maxProfitDecline: -3,
      spendOptimizationRatio: 1.5,
      efficiencyDropRatio: 1.5,
      proportionalRatio: 1.3
    },
    stable: { maxAbsoluteChange: 2 }
  };
  
  console.log(`Calculating growth status: spend=${spendPct.toFixed(1)}%, profit=${profitPct.toFixed(1)}%`);
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü–µ—Ä–µ—Ö–æ–¥—ã –º–µ–∂–¥—É –ø—Ä–∏–±—ã–ª—å—é –∏ —É–±—ã—Ç–∫–æ–º (–≤—Å–µ–≥–¥–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã)
  if (prevProfit < 0 && currProfit > 0) {
    console.log('Status: Profit transition positive');
    return 'üü¢ Healthy Growth';
  }
  if (prevProfit > 0 && currProfit < 0) {
    console.log('Status: Profit transition negative');
    return 'üî¥ Inefficient Growth';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –ø–∞–¥–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏—Ç–∞
  if (profitPct <= thresholds.inefficientGrowth.maxProfitChange) {
    console.log('Status: Critical profit decline');
    return 'üî¥ Inefficient Growth';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 3: –ó–¥–æ—Ä–æ–≤—ã–π —Ä–æ—Å—Ç
  if (spendPct >= thresholds.healthyGrowth.minSpendChange && 
      profitPct >= thresholds.healthyGrowth.minProfitChange) {
    console.log('Status: Healthy growth criteria met');
    return 'üü¢ Healthy Growth';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 4: –£–ª—É—á—à–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
  // –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
  if (spendPct <= thresholds.efficiencyImprovement.maxSpendDecline && 
      profitPct >= thresholds.efficiencyImprovement.minProfitGrowth) {
    console.log('Status: Significant efficiency improvement');
    return 'üü¢ Efficiency Improvement';
  }
  // –£–º–µ—Ä–µ–Ω–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
  if (spendPct <= thresholds.efficiencyImprovement.maxSpendDecline && 
      profitPct > 0 && profitPct < thresholds.efficiencyImprovement.minProfitGrowth) {
    console.log('Status: Moderate efficiency improvement');
    return 'üü° Efficiency Improvement';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 5: Scaling Down —Å—Ü–µ–Ω–∞—Ä–∏–∏
  if (spendPct <= thresholds.scalingDown.maxSpendChange) {
    if (profitPct >= thresholds.scalingDown.efficient.minProfitChange) {
      console.log('Status: Efficient scaling down');
      return 'üîµ Scaling Down - Efficient';
    }
    if (profitPct >= thresholds.scalingDown.moderate.minProfitDecline && 
        profitPct <= thresholds.scalingDown.moderate.maxProfitDecline) {
      console.log('Status: Moderate scaling down');
      return 'üîµ Scaling Down - Moderate';
    }
    if (profitPct <= thresholds.scalingDown.problematic.maxProfitDecline) {
      console.log('Status: Problematic scaling down');
      return 'üîµ Scaling Down - Problematic';
    }
    console.log('Status: General scaling down');
    return 'üîµ Scaling Down';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 6: –°–Ω–∏–∂–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
  if (spendPct >= thresholds.decliningEfficiency.minSpendStable && 
      spendPct <= thresholds.decliningEfficiency.maxSpendGrowth &&
      profitPct >= thresholds.decliningEfficiency.maxProfitDecline && 
      profitPct <= thresholds.decliningEfficiency.minProfitDecline) {
    console.log('Status: Declining efficiency');
    return 'üü† Declining Efficiency';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 7: –£–º–µ—Ä–µ–Ω–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ —Å–ø–∞–¥–∞
  if (spendPct < 0 && profitPct < 0 && 
      spendPct >= thresholds.moderateDecline.maxSpendDecline && 
      profitPct >= thresholds.moderateDecline.maxProfitDecline) {
    
    const spendDeclineAbs = Math.abs(spendPct);
    const profitDeclineAbs = Math.abs(profitPct);
    
    // –°–ø–µ–Ω–¥ –ø–∞–¥–∞–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ –ø—Ä–æ—Ñ–∏—Ç–∞ = –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
    if (spendDeclineAbs >= profitDeclineAbs * thresholds.moderateDecline.spendOptimizationRatio) {
      console.log('Status: Spend optimization decline');
      return 'üü° Moderate Decline - Spend Optimization';
    }
    // –ü—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ —Å–ø–µ–Ω–¥–∞ = –ø–∞–¥–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    if (profitDeclineAbs >= spendDeclineAbs * thresholds.moderateDecline.efficiencyDropRatio) {
      console.log('Status: Efficiency drop decline');
      return 'üü° Moderate Decline - Efficiency Drop';
    }
    // –û–±–∞ –ø–∞–¥–∞—é—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ –æ–¥–∏–Ω–∞–∫–æ–≤–æ
    console.log('Status: Proportional decline');
    return 'üü° Moderate Decline - Proportional';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 8: –£–º–µ—Ä–µ–Ω–Ω—ã–π —Ä–æ—Å—Ç
  if (spendPct >= thresholds.moderateGrowthSpend && 
      profitPct >= thresholds.moderateGrowthProfit &&
      (spendPct < thresholds.healthyGrowth.minSpendChange || profitPct < thresholds.healthyGrowth.minProfitChange)) {
    console.log('Status: Moderate growth');
    return 'üü° Moderate Growth';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 9: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–æ—Å—Ç
  if (spendPct > 0 && profitPct > 0) {
    if (spendPct <= thresholds.minimalGrowth.maxSpendChange && 
        profitPct <= thresholds.minimalGrowth.maxProfitChange) {
      console.log('Status: Minimal growth (small)');
      return 'üü° Minimal Growth';
    }
    if (spendPct < thresholds.moderateGrowthSpend || profitPct < thresholds.moderateGrowthProfit) {
      console.log('Status: Minimal growth (below moderate)');
      return 'üü° Minimal Growth';
    }
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 10: –û–±—â–∏–π —É–º–µ—Ä–µ–Ω–Ω—ã–π —Å–ø–∞–¥
  if (spendPct < 0 && profitPct < 0 && 
      spendPct >= thresholds.scalingDown.maxSpendChange && 
      profitPct >= thresholds.inefficientGrowth.maxProfitChange) {
    console.log('Status: General moderate decline');
    return 'üü° Moderate Decline';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 11: –ü–æ–≥—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ declining efficiency
  
  // –°–ø–µ–Ω–¥ —Ä–∞—Å—Ç–µ—Ç —É–º–µ—Ä–µ–Ω–Ω–æ, –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç —É–º–µ—Ä–µ–Ω–Ω–æ
  if (spendPct > 0 && spendPct <= 15 && profitPct < 0 && profitPct >= -10) {
    console.log('Status: Borderline declining efficiency (spend up, profit down)');
    return 'üü† Declining Efficiency';
  }
  
  // –°–ø–µ–Ω–¥ —Å—Ç–∞–±–∏–ª–µ–Ω, –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç —É–º–µ—Ä–µ–Ω–Ω–æ
  if (Math.abs(spendPct) <= 5 && profitPct < -2 && profitPct >= -12) {
    console.log('Status: Borderline declining efficiency (spend stable, profit down)');
    return 'üü† Declining Efficiency';
  }
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ 12: –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
  if (Math.abs(spendPct) <= thresholds.stable.maxAbsoluteChange && 
      Math.abs(profitPct) <= thresholds.stable.maxAbsoluteChange) {
    console.log('Status: Stable (strict)');
    return '‚ö™ Stable';
  }
  
  // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
  if (Math.abs(spendPct) <= 10 && Math.abs(profitPct) <= 10) {
    console.log('Status: Stable (extended)');
    return '‚ö™ Stable';
  }
  
  // Fallback
  console.log('Status: Fallback to stable');
  return '‚ö™ Stable';
}

/**
 * Calculate growth status for specific project using its thresholds
 */
function calculateProjectGrowthStatus(projectName, prev, curr, spendPct, profitPct, profitField = 'eProfitForecast') {
  const originalProject = CURRENT_PROJECT;
  setCurrentProject(projectName);
  
  try {
    return calculateGrowthStatus(prev, curr, spendPct, profitPct, profitField);
  } finally {
    setCurrentProject(originalProject);
  }
}

/**
 * Get growth status explanation for current project
 */
function getGrowthStatusExplanation() {
  return `Growth Status Criteria for ${CURRENT_PROJECT}:

üü¢ –ü–û–ó–ò–¢–ò–í–ù–´–ï –°–¶–ï–ù–ê–†–ò–ò:
- Healthy Growth: Spend ‚â•10% AND Profit ‚â•5%
- Efficiency Improvement: –°–ø–µ–Ω–¥ –ø–∞–¥–∞–µ—Ç, –ø—Ä–æ—Ñ–∏—Ç —Ä–∞—Å—Ç–µ—Ç
- –ü–µ—Ä–µ—Ö–æ–¥ –∏–∑ —É–±—ã—Ç–∫–∞ –≤ –ø—Ä–∏–±—ã–ª—å

üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –°–¶–ï–ù–ê–†–ò–ò:
- Inefficient Growth: Profit ‚â§-8%
- –ü–µ—Ä–µ—Ö–æ–¥ –∏–∑ –ø—Ä–∏–±—ã–ª–∏ –≤ —É–±—ã—Ç–æ–∫

üü† –ü–†–ï–î–£–ü–†–ï–ñ–î–ê–Æ–©–ò–ï –°–¶–ï–ù–ê–†–ò–ò:
- Declining Efficiency: –°–ø–µ–Ω–¥ —Ä–∞—Å—Ç–µ—Ç/—Å—Ç–∞–±–∏–ª–µ–Ω, –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç —É–º–µ—Ä–µ–Ω–Ω–æ

üîµ –°–¶–ï–ù–ê–†–ò–ò –°–û–ö–†–ê–©–ï–ù–ò–Ø:
- Scaling Down: Spend ‚â§-15%
  - Efficient: –ø—Ä–æ—Ñ–∏—Ç —Å—Ç–∞–±–∏–ª–µ–Ω/—Ä–∞—Å—Ç–µ—Ç
  - Moderate: –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç —É–º–µ—Ä–µ–Ω–Ω–æ
  - Problematic: –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç —Å–∏–ª—å–Ω–æ

üü° –£–ú–ï–†–ï–ù–ù–´–ï –°–¶–ï–ù–ê–†–ò–ò:
- Moderate Growth: Spend >3% AND Profit >2%
- Minimal Growth: –ù–µ–±–æ–ª—å—à–∏–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
- Moderate Decline: –£–º–µ—Ä–µ–Ω–Ω—ã–µ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
  - Spend Optimization: —Å–ø–µ–Ω–¥ –ø–∞–¥–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ
  - Efficiency Drop: –ø—Ä–æ—Ñ–∏—Ç –ø–∞–¥–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ
  - Proportional: –æ–±–∞ –ø–∞–¥–∞—é—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ

‚ö™ –°–¢–ê–ë–ò–õ–¨–ù–´–ï –°–¶–ï–ù–ê–†–ò–ò:
- Stable: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É`;
}

/**
 * Get growth status explanation for specific project
 */
function getProjectGrowthStatusExplanation(projectName) {
  const originalProject = CURRENT_PROJECT;
  setCurrentProject(projectName);
  
  try {
    return getGrowthStatusExplanation();
  } finally {
    setCurrentProject(originalProject);
  }
}

/**
 * Get detailed scenario analysis for debugging
 */
function analyzeGrowthScenario(spendPct, profitPct, projectName = CURRENT_PROJECT) {
  const analysis = {
    spendPct,
    profitPct,
    projectName
  };
  
  // Simulate the status calculation
  const mockPrev = { eProfitForecast: 100, spend: 100 };
  const mockCurr = { eProfitForecast: 100 + profitPct, spend: 100 + spendPct };
  
  const originalProject = CURRENT_PROJECT;
  setCurrentProject(projectName);
  analysis.status = calculateGrowthStatus(mockPrev, mockCurr, spendPct, profitPct);
  setCurrentProject(originalProject);
  
  return analysis;
}

/**
 * Main: generate report for the last N days without progress indicators
 */
function generateReport(days) {
  try {
    const config = getCurrentConfig();
    
    // Save existing comments first
    const spreadsheet = SpreadsheetApp.openById(config.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(config.SHEET_NAME);
    
    if (sheet && sheet.getLastRow() > 1) {
      expandAllGroups(sheet);
      const cache = new CommentCache();
      cache.syncCommentsFromSheet();
    } else {
      const cache = new CommentCache();
    }
    
    // Calculate date range
    const dateRange = getDateRange(days);
    
    // Fetch data from API
    const raw = fetchCampaignData(dateRange);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      SpreadsheetApp.getUi().alert('No data found for the specified period.');
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    if (Object.keys(processed).length === 0) {
      SpreadsheetApp.getUi().alert('No valid data to process.');
      return;
    }
    
    // Clear and create report
    clearAllDataSilent();
    createEnhancedPivotTable(processed);
    
    // Restore comments
    const cache = new CommentCache();
    cache.applyCommentsToSheet();
    
  } catch (e) {
    console.error('Error generating report:', e);
    SpreadsheetApp.getUi().alert('Error', 'Error generating report: ' + e.toString(), SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Generate report for specific date range without progress indicators
 */
function generateReportForDateRange(startDate, endDate) {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const config = getCurrentConfig();
    
    // Save existing comments first
    const spreadsheet = SpreadsheetApp.openById(config.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(config.SHEET_NAME);
    
    if (sheet && sheet.getLastRow() > 1) {
      expandAllGroups(sheet);
      const cache = new CommentCache();
      cache.syncCommentsFromSheet();
    } else {
      const cache = new CommentCache();
    }
    
    // Fetch data from API
    const dateRange = { from: startDate, to: endDate };
    const raw = fetchCampaignData(dateRange);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      ui.alert('No Data', 'No data found for the selected date range.', ui.ButtonSet.OK);
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    if (Object.keys(processed).length === 0) {
      ui.alert('No Valid Data', 'No valid data to process for the selected date range.', ui.ButtonSet.OK);
      return;
    }
    
    // Clear and create report
    clearAllDataSilent();
    createEnhancedPivotTable(processed);
    
    // Restore comments
    const cache = new CommentCache();
    cache.applyCommentsToSheet();
    
    ui.alert('Success', `Report generated successfully!\n\nDate range: ${startDate} to ${endDate}`, ui.ButtonSet.OK);
  } catch (e) {
    console.error('Error generating report for date range:', e);
    ui.alert(
      'Error', 
      'Error generating report:\n\n' + e.toString() + '\n\nPlease check:\n' +
      '1. Your internet connection\n' +
      '2. The API token is still valid\n' +
      '3. Try a smaller date range',
      ui.ButtonSet.OK
    );
  }
}

/**
 * Update all data to current - fetches from first existing week to current date
 */
function updateAllDataToCurrent() {
  const ui = SpreadsheetApp.getUi();
  const config = getCurrentConfig();
  const spreadsheet = SpreadsheetApp.openById(config.SHEET_ID);
  const sheet = spreadsheet.getSheetByName(config.SHEET_NAME);
  
  if (!sheet || sheet.getLastRow() < 2) {
    ui.alert('No existing data found. Please create a report first.');
    return;
  }
  
  try {
    // Expand all groups first to ensure we can read all data
    expandAllGroups(sheet);
    
    // Save existing comments first
    const cache = new CommentCache();
    cache.syncCommentsFromSheet();
    
    // Find the earliest week in the sheet
    let earliestDate = null;
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === 'WEEK') {
        const weekRange = data[i][1];
        const [startStr, endStr] = weekRange.split(' - ');
        const startDate = new Date(startStr);
        if (!earliestDate || startDate < earliestDate) {
          earliestDate = startDate;
        }
      }
    }
    
    if (!earliestDate) {
      ui.alert('No week data found in the sheet.');
      return;
    }
    
    // Calculate date range from earliest date to yesterday (excluding current incomplete week)
    const today = new Date();
    const dayOfWeek = today.getDay();
    let endDate;
    if (dayOfWeek === 0) {
      // Today is Sunday, include up to yesterday (Saturday)
      endDate = new Date(today);
      endDate.setDate(today.getDate() - 1);
    } else {
      // Today is Mon-Sat, include up to last Saturday
      const daysFromLastSaturday = dayOfWeek === 0 ? 1 : dayOfWeek;
      endDate = new Date(today);
      endDate.setDate(today.getDate() - daysFromLastSaturday);
    }
    
    const dateRange = {
      from: formatDateForAPI(earliestDate),
      to: formatDateForAPI(endDate)
    };
    
    // Fetch all data for the complete range
    const raw = fetchCampaignData(dateRange);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      ui.alert('No data found for the date range.');
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    
    if (Object.keys(processed).length === 0) {
      ui.alert('No valid data to process.');
      return;
    }
    
    // Clear old data silently
    clearAllDataSilent();
    
    // Create updated report
    createEnhancedPivotTable(processed);
    
    // Restore comments
    cache.applyCommentsToSheet();
    
    ui.alert('Success', `Successfully updated all data from ${dateRange.from} to ${dateRange.to}!`, ui.ButtonSet.OK);
    
  } catch (e) {
    console.error('Error updating data:', e);
    ui.alert('Error', 'Error updating data: ' + e.toString(), ui.ButtonSet.OK);
  }
}
