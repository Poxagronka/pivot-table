// Configuration
const CONFIG = {
  SHEET_ID: '1sU3G0HYgv-xX1UGK4Qa_4jhpc7vndtRyKsojyVx9iaE',
  SHEET_NAME: 'Pivot',
  API_URL: 'https://app.appodeal.com/graphql',
  TARGET_EROAS: 160, // Target eROAS percentage
  BEARER_TOKEN: 'eyJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJBcHBvZGVhbCIsImF1ZCI6WyJBcHBvZGVhbCJdLCJhZG1pbiI6dHJ1ZSwic3ViIjoyMzU4MzcsInR5cCI6ImFjY2VzcyIsImV4cCI6MTc1MDAxNzM4MX0.qstjfLVhoxajqhv82INuqs0fDDGWYFOCDf4gkV17Rv9HTLwG2OM_IbOqh4dh6vko1VINteY4AE9C3ZL6h15zGA',
  COMMENTS_CACHE_SHEET: 'CommentsCache' // Hidden sheet for storing comments
};

/**
 * Comment Cache Management
 */
class CommentCache {
  constructor() {
    this.cacheSheet = this.getOrCreateCacheSheet();
  }

  getOrCreateCacheSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    let sheet = spreadsheet.getSheetByName(CONFIG.COMMENTS_CACHE_SHEET);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(CONFIG.COMMENTS_CACHE_SHEET);
      sheet.hideSheet();
      // Headers: AppName, WeekRange, Comment, LastUpdated
      sheet.getRange(1, 1, 1, 4).setValues([['AppName', 'WeekRange', 'Comment', 'LastUpdated']]);
    }
    return sheet;
  }

  getCommentKey(appName, weekRange) {
    return `${appName}|||${weekRange}`;
  }

  loadAllComments() {
    const comments = {};
    const data = this.cacheSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      const [appName, weekRange, comment, lastUpdated] = data[i];
      if (comment) {
        const key = this.getCommentKey(appName, weekRange);
        comments[key] = comment;
      }
    }
    return comments;
  }

  saveComment(appName, weekRange, comment) {
    if (!comment || !comment.trim()) return;
    
    const data = this.cacheSheet.getDataRange().getValues();
    let found = false;
    
    // Update existing or add new
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === appName && data[i][1] === weekRange) {
        // Only update if new comment is longer (appending text)
        const existingComment = data[i][2] || '';
        if (comment.length > existingComment.length) {
          this.cacheSheet.getRange(i + 1, 3, 1, 2).setValues([[comment, new Date()]]);
        }
        found = true;
        break;
      }
    }
    
    if (!found) {
      const lastRow = this.cacheSheet.getLastRow();
      this.cacheSheet.getRange(lastRow + 1, 1, 1, 4).setValues([[appName, weekRange, comment, new Date()]]);
    }
  }

  syncCommentsFromSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // Expand all groups to ensure we can read all data
    expandAllGroups(sheet);
    
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }

  applyCommentsToSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    const comments = this.loadAllComments();
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp) {
        const key = this.getCommentKey(currentApp, nameOrRange);
        const comment = comments[key];
        if (comment) {
          sheet.getRange(i + 1, 16).setValue(comment); // Comments column
        }
      }
    }
  }
}

/**
 * Progress Management - Used only for manual comment saving
 */
class ProgressManager {
  constructor(title = 'Processing...') {
    this.progressSheet = null;
    this.startTime = new Date();
    this.title = title;
  }

  start(initialStatus = 'Initializing...') {
    try {
      const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
      this.progressSheet = spreadsheet.insertSheet(this.title);
      this.progressSheet.getRange('A1').setValue(this.title).setFontSize(16).setFontWeight('bold');
      this.progressSheet.getRange('A2').setValue(`Started: ${this.startTime.toLocaleString()}`);
      this.progressSheet.getRange('A3').setValue('Status: ' + initialStatus);
      this.progressSheet.getRange('A5').setValue('Please wait, do not modify the spreadsheet...');
      this.progressSheet.setColumnWidth(1, 500);
      SpreadsheetApp.flush();
    } catch (e) {
      console.error('Error creating progress sheet:', e);
    }
    return this;
  }

  update(status, details = null) {
    if (!this.progressSheet) return;
    try {
      this.progressSheet.getRange('A3').setValue('Status: ' + status);
      if (details) {
        this.progressSheet.getRange('A4').setValue('Details: ' + details);
      }
      const elapsed = Math.round((new Date() - this.startTime) / 1000);
      this.progressSheet.getRange('A6').setValue(`Elapsed: ${elapsed} seconds`);
      SpreadsheetApp.flush();
    } catch (e) {
      console.error('Error updating progress:', e);
    }
  }

  end(showSuccess = true) {
    if (!this.progressSheet) return;
    try {
      if (showSuccess) {
        this.update('Completed successfully!');
        Utilities.sleep(1500);
      }
      SpreadsheetApp.getActiveSpreadsheet().deleteSheet(this.progressSheet);
    } catch (e) {
      console.error('Error removing progress sheet:', e);
    }
  }
}

/**
 * Добавляем пользовательское меню в интерфейс Google Sheets
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Campaign Report')
    .addItem('Create report - Last 30 days', 'generateReport30')
    .addItem('Create report - Last 60 days', 'generateReport60')
    .addItem('Create report - Last 90 days', 'generateReport90')
    .addItem('Create report - Custom days', 'showDaysDialog')
    .addItem('Create report - Date range', 'showDateRangeDialog')
    .addSeparator()
    .addItem('Update all data to current', 'updateAllDataToCurrent')
    .addSeparator()
    .addItem('Save comments to cache', 'saveCommentsToCache')
    .addItem('Clear all data', 'clearAllData')
    .addToUi();
}

// Quick report functions
function generateReport30() { generateReport(30); }
function generateReport60() { generateReport(60); }
function generateReport90() { generateReport(90); }

/**
 * Save comments to cache manually - only this function shows progress
 */
function saveCommentsToCache() {
  const progress = new ProgressManager('Saving Comments').start('Preparing sheet...');
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      progress.end(false);
      SpreadsheetApp.getUi().alert('No data found in the sheet.');
      return;
    }
    
    progress.update('Expanding all groups...');
    expandAllGroups(sheet);
    
    progress.update('Reading comments from sheet...');
    const cache = new CommentCache();
    cache.syncCommentsFromSheet();
    
    progress.update('Comments saved successfully!');
    progress.end();
    SpreadsheetApp.getUi().alert('Success', 'Comments have been saved to cache.', SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    progress.end(false);
    SpreadsheetApp.getUi().alert('Error', 'Error saving comments: ' + e.toString(), SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Диалог для ввода числа дней и запуска отчёта
 */
function showDaysDialog() {
  const ui = SpreadsheetApp.getUi();
  const daysResp = ui.prompt('Custom Report', 'Input number of days (30, 60, 90, 120, 360):', ui.ButtonSet.OK_CANCEL);
  if (daysResp.getSelectedButton() !== ui.Button.OK) return;
  const days = parseInt(daysResp.getResponseText(), 10);
  if (![30, 60, 90, 120, 360].includes(days)) {
    ui.alert('Invalid value. Please enter one of: 30, 60, 90, 120, or 360');
    return;
  }
  generateReport(days);
}

/**
 * Диалог для ввода диапазона дат - используем только простые prompts
 */
function showDateRangeDialog() {
  const ui = SpreadsheetApp.getUi();
  
  // Get start date
  const startResp = ui.prompt(
    'Date Range Report - Start Date',
    'Enter start date (YYYY-MM-DD format):\n\nExample: 2025-01-01',
    ui.ButtonSet.OK_CANCEL
  );
  
  if (startResp.getSelectedButton() !== ui.Button.OK) return;
  
  const startDate = startResp.getResponseText().trim();
  if (!isValidDate(startDate)) {
    ui.alert('Error', 'Invalid start date format. Please use YYYY-MM-DD format.\n\nExample: 2025-01-01', ui.ButtonSet.OK);
    return;
  }
  
  // Get end date
  const endResp = ui.prompt(
    'Date Range Report - End Date',
    'Enter end date (YYYY-MM-DD format):\n\nExample: 2025-01-31',
    ui.ButtonSet.OK_CANCEL
  );
  
  if (endResp.getSelectedButton() !== ui.Button.OK) return;
  
  const endDate = endResp.getResponseText().trim();
  if (!isValidDate(endDate)) {
    ui.alert('Error', 'Invalid end date format. Please use YYYY-MM-DD format.\n\nExample: 2025-01-31', ui.ButtonSet.OK);
    return;
  }
  
  // Validate date range
  if (startDate > endDate) {
    ui.alert('Error', 'Start date must be before end date.', ui.ButtonSet.OK);
    return;
  }
  
  // Generate report without confirmation
  generateReportForDateRange(startDate, endDate);
}

/**
 * Validate date format
 */
function isValidDate(dateString) {
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(dateString)) return false;
  
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date);
}

/**
 * Generate report for specific date range without progress indicators
 */
function generateReportForDateRange(startDate, endDate) {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Save existing comments first
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (sheet && sheet.getLastRow() > 1) {
      expandAllGroups(sheet);
      const cache = new CommentCache();
      cache.syncCommentsFromSheet();
    } else {
      const cache = new CommentCache();
    }
    
    // Fetch data from API
    const dateRange = { from: startDate, to: endDate };
    const raw = fetchCampaignData(dateRange);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      ui.alert('No Data', 'No data found for the selected date range.', ui.ButtonSet.OK);
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    if (Object.keys(processed).length === 0) {
      ui.alert('No Valid Data', 'No valid data to process for the selected date range.', ui.ButtonSet.OK);
      return;
    }
    
    // Clear and create report
    clearAllDataSilent();
    createEnhancedPivotTable(processed);
    
    // Restore comments
    const cache = new CommentCache();
    cache.applyCommentsToSheet();
    
    ui.alert('Success', `Report generated successfully!\n\nDate range: ${startDate} to ${endDate}`, ui.ButtonSet.OK);
  } catch (e) {
    console.error('Error generating report for date range:', e);
    ui.alert(
      'Error', 
      'Error generating report:\n\n' + e.toString() + '\n\nPlease check:\n' +
      '1. Your internet connection\n' +
      '2. The API token is still valid\n' +
      '3. Try a smaller date range',
      ui.ButtonSet.OK
    );
  }
}

/**
 * Update all data to current - fetches from first existing week to current date
 */
function updateAllDataToCurrent() {
  const ui = SpreadsheetApp.getUi();
  const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
  const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
  
  if (!sheet || sheet.getLastRow() < 2) {
    ui.alert('No existing data found. Please create a report first.');
    return;
  }
  
  try {
    // Expand all groups first to ensure we can read all data
    expandAllGroups(sheet);
    
    // Save existing comments first
    const cache = new CommentCache();
    cache.syncCommentsFromSheet();
    
    // Find the earliest week in the sheet
    let earliestDate = null;
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === 'WEEK') {
        const weekRange = data[i][1];
        const [startStr, endStr] = weekRange.split(' - ');
        const startDate = new Date(startStr);
        if (!earliestDate || startDate < earliestDate) {
          earliestDate = startDate;
        }
      }
    }
    
    if (!earliestDate) {
      ui.alert('No week data found in the sheet.');
      return;
    }
    
    // Calculate date range from earliest date to yesterday (excluding current incomplete week)
    const today = new Date();
    const dayOfWeek = today.getDay();
    // If today is Sunday (0), we include up to Saturday (yesterday)
    // Otherwise, we include up to last Saturday
    let endDate;
    if (dayOfWeek === 0) {
      // Today is Sunday, include up to yesterday (Saturday)
      endDate = new Date(today);
      endDate.setDate(today.getDate() - 1);
    } else {
      // Today is Mon-Sat, include up to last Saturday
      const daysFromLastSaturday = dayOfWeek === 0 ? 1 : dayOfWeek;
      endDate = new Date(today);
      endDate.setDate(today.getDate() - daysFromLastSaturday);
    }
    
    const dateRange = {
      from: formatDateForAPI(earliestDate),
      to: formatDateForAPI(endDate)
    };
    
    // Fetch all data for the complete range
    const raw = fetchCampaignData(dateRange);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      ui.alert('No data found for the date range.');
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    
    if (Object.keys(processed).length === 0) {
      ui.alert('No valid data to process.');
      return;
    }
    
    // Clear old data silently
    clearAllDataSilent();
    
    // Create updated report
    createEnhancedPivotTable(processed);
    
    // Restore comments
    cache.applyCommentsToSheet();
    
    ui.alert('Success', `Successfully updated all data from ${dateRange.from} to ${dateRange.to}!`, ui.ButtonSet.OK);
    
  } catch (e) {
    console.error('Error updating data:', e);
    ui.alert('Error', 'Error updating data: ' + e.toString(), ui.ButtonSet.OK);
  }
}

/**
 * Helper functions
 */
function getMondayOfWeek(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  return new Date(d.setDate(diff));
}

function getSundayOfWeek(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() + (day === 0 ? 0 : 7 - day);
  return new Date(d.setDate(diff));
}

function formatDateForAPI(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Expand all groups in the sheet
 */
function expandAllGroups(sheet) {
  try {
    // Expand all row groups
    const maxRows = sheet.getMaxRows();
    // Try to expand multiple times to handle nested groups
    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        sheet.getRange(1, 1, maxRows, 1).expandGroups();
      } catch (e) {
        // No more groups to expand
        break;
      }
    }
  } catch (e) {
    console.log('No groups to expand or error expanding groups:', e);
  }
}

/**
 * Clear all existing groups in the sheet
 */
function clearAllGroups(sheet) {
  try {
    const maxRows = sheet.getMaxRows();
    // Keep removing group depth until there are no more groups
    let hasGroups = true;
    let attempts = 0;
    
    while (hasGroups && attempts < 10) {
      try {
        sheet.getRange(1, 1, maxRows, 1).shiftRowGroupDepth(-1);
        attempts++;
      } catch (e) {
        // No more groups to remove
        hasGroups = false;
      }
    }
  } catch (e) {
    console.log('Error clearing groups:', e);
  }
}

/**
 * Recreate grouping for the entire sheet
 */
function recreateGrouping(sheet) {
  // First, expand all existing groups to ensure we can work with all rows
  expandAllGroups(sheet);
  
  // Clear all existing groups
  clearAllGroups(sheet);
  
  // Recreate groups
  const data = sheet.getDataRange().getValues();
  createRowGrouping(sheet, data, null);
}

/**
 * Clear all data without UI prompts (for internal use)
 */
function clearAllDataSilent() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const tempSheetName = CONFIG.SHEET_NAME + '_temp_' + Date.now();
    const newSheet = spreadsheet.insertSheet(tempSheetName);
    const oldSheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (oldSheet) spreadsheet.deleteSheet(oldSheet);
    newSheet.setName(CONFIG.SHEET_NAME);
  } catch (error) {
    console.error('Error during sheet recreation:', error);
    throw error;
  }
}

/**
 * Clear all data by deleting and recreating the sheet - only shows confirmation when called from menu
 */
function clearAllData() {
  const ui = SpreadsheetApp.getUi();
  
  // Show confirmation dialog only for manual clearing
  const result = ui.alert(
    'Clear All Data',
    'This will delete all data in the Pivot sheet.\n\n' +
    'Comments will be preserved and can be restored later.\n\n' +
    'Are you sure you want to continue?',
    ui.ButtonSet.YES_NO
  );
  
  if (result !== ui.Button.YES) {
    return;
  }
  
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (sheet && sheet.getLastRow() > 1) {
      expandAllGroups(sheet);
      const cache = new CommentCache();
      cache.syncCommentsFromSheet();
    }
    
    clearAllDataSilent();
    
    ui.alert('Success', 'All data has been cleared. Comments have been preserved in cache.', ui.ButtonSet.OK);
  } catch (error) {
    console.error('Error during sheet recreation:', error);
    ui.alert('Error', 'Error clearing data: ' + error.toString(), ui.ButtonSet.OK);
  }
}

/**
 * Calculate date range for last N days (inclusive)
 */
function getDateRange(days) {
  const tz = SpreadsheetApp.getActive().getSpreadsheetTimeZone();
  const today = new Date();
  // Zero out time portion
  today.setHours(0, 0, 0, 0);
  const endDate = new Date(today);
  const startDate = new Date(today);
  startDate.setDate(startDate.getDate() - days + 1);
  return {
    from: Utilities.formatDate(startDate, tz, 'yyyy-MM-dd'),
    to:   Utilities.formatDate(endDate, tz, 'yyyy-MM-dd')
  };
}

/**
 * Main: generate report for the last N days without progress indicators
 */
function generateReport(days) {
  try {
    // Save existing comments first
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (sheet && sheet.getLastRow() > 1) {
      expandAllGroups(sheet);
      const cache = new CommentCache();
      cache.syncCommentsFromSheet();
    } else {
      const cache = new CommentCache();
    }
    
    // Calculate date range
    const dr = getDateRange(days);
    
    // Fetch data from API
    const raw = fetchCampaignData(dr);
    
    if (!raw.data?.analytics?.richStats?.stats?.length) {
      SpreadsheetApp.getUi().alert('No data found for the specified period.');
      return;
    }
    
    // Process data
    const processed = processApiData(raw);
    if (Object.keys(processed).length === 0) {
      SpreadsheetApp.getUi().alert('No valid data to process.');
      return;
    }
    
    // Clear and create report
    clearAllDataSilent();
    createEnhancedPivotTable(processed);
    
    // Restore comments
    const cache = new CommentCache();
    cache.applyCommentsToSheet();
    
  } catch (e) {
    console.error('Error generating report:', e);
    SpreadsheetApp.getUi().alert('Error', 'Error generating report: ' + e.toString(), SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Fetch data from API with обновлёнными заголовками
 */
function fetchCampaignData(dateRange) {
  const payload = {
    operationName: "RichStats",
    variables: {
      dateFilters: [{
        dimension: "INSTALL_DATE",
        from: dateRange.from,
        to: dateRange.to,
        include: true
      }],
      filters: [
        { dimension: "USER", values: ["79950","127168","157350","150140","11628","233863","239157"], include: true },
        { dimension: "ATTRIBUTION_PARTNER", values: ["Stack"], include: true },
        { dimension: "ATTRIBUTION_NETWORK_HID", values: ["234187180623265792"], include: true },
        { dimension: "ATTRIBUTION_CAMPAIGN_HID", values: [], include: true, searchByString: "/tricky/i" }
      ],
      groupBy: [
        { dimension: "INSTALL_DATE", timeBucket: "WEEK" },
        { dimension: "ATTRIBUTION_CAMPAIGN_HID" },
        { dimension: "APP" }
      ],
      measures: [
        { id: "cpi", day: null },
        { id: "installs", day: null },
        { id: "ipm", day: null },
        { id: "spend", day: null },
        { id: "roas", day: 1 },
        { id: "e_arpu_forecast", day: 365 },
        { id: "e_roas_forecast", day: 365 },
        { id: "e_profit_forecast", day: 730 }
      ],
      havingFilters: [],
      anonymizationMode: "OFF",
      topFilter: null,
      revenuePredictionVersion: "",
      isMultiMediation: true
    },
    query: `query RichStats($dateFilters: [DateFilterInput!]!, $filters: [FilterInput!]!, $groupBy: [GroupByInput!]!, $measures: [RichMeasureInput!]!, $havingFilters: [HavingFilterInput!], $anonymizationMode: DataAnonymizationMode, $revenuePredictionVersion: String!, $topFilter: TopFilterInput, $funnelFilter: FunnelAttributes, $isMultiMediation: Boolean) {
      analytics(anonymizationMode: $anonymizationMode) {
        richStats(
          funnelFilter: $funnelFilter
          dateFilters: $dateFilters
          filters: $filters
          groupBy: $groupBy
          measures: $measures
          havingFilters: $havingFilters
          revenuePredictionVersion: $revenuePredictionVersion
          topFilter: $topFilter
          isMultiMediation: $isMultiMediation
        ) {
          stats {
            id
            ... on RetentionStatsValue { value cohortSize __typename }
            ... on ForecastStatsItem { value uncertainForecast __typename }
            ... on AppInfo { name platform bundleId __typename }
            ... on LineItemInfo { value appId __typename }
            ... on StatsValue { value __typename }
            ... on SegmentInfo { name description __typename }
            ... on WaterfallConfigurationStats { value appId __typename }
            ... on CountryInfo { code value __typename }
            ... on UaAdSet {
              hid accountId adSetId appId budget budgetPeriod name cpc createdAt lastBidChangedAt
              network recommendedTargetCpa targetCpa targetDayN updatedAt isBeingUpdated isAutomated
              status url type permissions { canUpdateBid canUpdateAutoBid canUpdateBudget canUpdateStatus __typename }
              __typename
            }
            ... on UaCampaign {
              hid accountId campaignId appId budget budgetPeriod campaignName cpc createdAt
              lastBidChangedAt network recommendedTargetCpa targetCpa targetDayN updatedAt
              isBeingUpdated isAutomated autoBidsIgnored status url type permissions {
                canUpdateBid canUpdateAutoBid canUpdateBudget canUpdateStatus __typename
              }
              __typename
            }
            ... on UaCampaignCountry { code bid isBeingUpdated recommendedBid budget country countryId status permissions { canUpdateBid canUpdateAutoBid canUpdateBudget canUpdateStatus __typename } __typename }
            ... on UaCampaignCountrySourceApp { bid iconUrl isBeingUpdated name recommendedBid sourceApp status storeUrl permissions { canUpdateBid canUpdateAutoBid canUpdateBudget canUpdateStatus __typename } __typename }
            ... on SourceAppInfo { name iconUrl storeUrl __typename }
            __typename
          }
          totals {
            day measure value {
              id
              ... on StatsValue { value __typename }
              ... on WaterfallConfigurationStats { value __typename }
              ... on RetentionStatsValue { value cohortSize __typename }
              ... on ForecastStatsItem { value uncertainForecast __typename }
              __typename
            }
            __typename
          }
          anonDict {
            id
            from { id ... on StatsValue { value __typename } __typename }
            to {
              id
              ... on RetentionStatsValue { value cohortSize __typename }
              ... on ForecastStatsItem { value uncertainForecast __typename }
              ... on AppInfo { name __typename }
              ... on StatsValue { value __typename }
              ... on SegmentInfo { name description __typename }
              ... on UaAdSet { name __typename }
              ... on UaCampaign { campaignName __typename }
              __typename
            }
            __typename
          }
          __typename
        }
        __typename
      }
    }`
  };

  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      Accept: 'application/json, text/plain, */*',
      'Accept-Language': 'en-US,en;q=0.9',
      Authorization: `Bearer ${CONFIG.BEARER_TOKEN}`,
      Connection: 'keep-alive',
      DNT: '1',
      Origin: 'https://app.appodeal.com',
      Referer: 'https://app.appodeal.com/analytics/reports?reloadTime=' + Date.now(),
      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36',
      'x-requested-with': 'XMLHttpRequest',
      'Trace-Id': Utilities.getUuid()
    },
    payload: JSON.stringify(payload)
  };

  const resp = UrlFetchApp.fetch(CONFIG.API_URL, options);
  if (resp.getResponseCode() !== 200) {
    throw new Error('API request failed: ' + resp.getContentText());
  }
  return JSON.parse(resp.getContentText());
}

/**
 * Process API data and group by apps, then weeks,
 * при этом пропускаем данные по текущей неделе
 */
function processApiData(rawData) {
  const stats = rawData.data.analytics.richStats.stats;
  const appData = {};

  // Вычисляем начало (Monday) текущей недели
  const today = new Date();
  const currentWeekStart = formatDateForAPI(getMondayOfWeek(today));

  stats.forEach((row, index) => {
    try {
      const date = row[0].value;
      const monday = getMondayOfWeek(new Date(date));
      const weekKey = formatDateForAPI(monday);

      // Если это текущая неделя — пропускаем
      if (weekKey >= currentWeekStart) {
        return;
      }

      const campaign = row[1];
      const app = row[2];
      const cpi = parseFloat(row[3].value) || 0;
      const installs = parseInt(row[4].value) || 0;
      const ipm = parseFloat(row[5].value) || 0;
      const spend = parseFloat(row[6].value) || 0;
      const roas = parseFloat(row[7].value) || 0;
      const eArpuForecast = parseFloat(row[8].value) || 0;
      const eRoasForecast = parseFloat(row[9].value) || 0;
      const eProfitForecast = parseFloat(row[10].value) || 0;

      const sunday = getSundayOfWeek(new Date(date));

      const appKey = app.id;
      if (!appData[appKey]) {
        appData[appKey] = {
          appId: app.id,
          appName: app.name,
          platform: app.platform,
          bundleId: app.bundleId,
          weeks: {}
        };
      }

      if (!appData[appKey].weeks[weekKey]) {
        appData[appKey].weeks[weekKey] = {
          weekStart: formatDateForAPI(monday),
          weekEnd: formatDateForAPI(sunday),
          campaigns: []
        };
      }

      const geo = campaign.campaignName.includes('| USA |') ? 'USA' :
                   campaign.campaignName.includes('| MEX |') ? 'MEX' :
                   campaign.campaignName.includes('| AUS |') ? 'AUS' :
                   campaign.campaignName.includes('| DEU |') ? 'DEU' :
                   campaign.campaignName.includes('| JPN |') ? 'JPN' :
                   campaign.campaignName.includes('| KOR |') ? 'KOR' :
                   campaign.campaignName.includes('| BRA |') ? 'BRA' :
                   campaign.campaignName.includes('| CAN |') ? 'CAN' :
                   campaign.campaignName.includes('| GBR |') ? 'GBR' : 'OTHER';

      function extractSourceApp(campaignName) {
        try {
          const eq = campaignName.indexOf('=');
          if (eq !== -1) {
            let t = campaignName.substring(eq + 1).trim();
            const subs = [];
            let idx = t.indexOf('subj');
            while (idx !== -1) {
              subs.push(idx);
              idx = t.indexOf('subj', idx + 1);
            }
            if (subs.length >= 2) t = t.substring(0, subs[1]).trim();
            else if (subs.length === 1 && subs[0] > 10) t = t.substring(0, subs[0]).trim();
            t = t.replace(/autobudget$/, '').trim();
            if (t) return t;
          }
          const lp = campaignName.lastIndexOf('|');
          if (lp !== -1) return campaignName.substring(lp + 1).trim();
          return 'Unknown';
        } catch (e) {
          return 'Unknown';
        }
      }

      const sourceApp = extractSourceApp(campaign.campaignName);

      appData[appKey].weeks[weekKey].campaigns.push({
        date: date,
        campaignId: campaign.campaignId,
        campaignName: campaign.campaignName,
        cpi,
        installs,
        ipm,
        spend,
        roas,
        eArpuForecast,
        eRoasForecast,
        eProfitForecast,
        status: campaign.status,
        type: campaign.type,
        geo,
        sourceApp,
        isAutomated: campaign.isAutomated
      });

    } catch (error) {
      console.error(`Error processing row ${index}:`, error);
    }
  });

  return appData;
}

/**
 * Calculate Week-over-Week metrics per app and per sourceApp
 */
function calculateWoWMetrics(appData) {
  if (!appData || typeof appData !== 'object') {
    console.error('Invalid appData provided to calculateWoWMetrics');
    return { sourceAppWoW: {}, appWeekWoW: {} };
  }

  try {
    const sourceAppData = {};
    const appWeekData = {};

    // Aggregate raw data
    Object.values(appData).forEach(app => {
      appWeekData[app.appName] = {};
      Object.values(app.weeks).forEach(week => {
        const spend = week.campaigns.reduce((s, c) => s + c.spend, 0);
        const profit = week.campaigns.reduce((s, c) => s + c.eProfitForecast, 0);
        appWeekData[app.appName][week.weekStart] = { weekStart: week.weekStart, spend, profit };

        week.campaigns.forEach(c => {
          if (c.sourceApp) {
            const key = `${c.sourceApp}_${week.weekStart}`;
            if (!sourceAppData[key]) {
              sourceAppData[key] = { sourceApp: c.sourceApp, weekStart: week.weekStart, spend: 0, eRoasForecast: 0, eProfitForecast: 0, count: 0 };
            }
            sourceAppData[key].spend += c.spend;
            sourceAppData[key].eRoasForecast += c.eRoasForecast;
            sourceAppData[key].eProfitForecast += c.eProfitForecast;
            sourceAppData[key].count += 1;
          }
        });
      });
    });

    // Compute sourceApp WoW
    const sourceApps = {};
    Object.values(sourceAppData).forEach(d => {
      if (d.count) d.eRoasForecast /= d.count;
      if (!sourceApps[d.sourceApp]) sourceApps[d.sourceApp] = [];
      sourceApps[d.sourceApp].push(d);
    });

    const sourceAppWoW = {};
    Object.keys(sourceApps).forEach(sa => {
      sourceApps[sa].sort((a, b) => new Date(a.weekStart) - new Date(b.weekStart));
      sourceApps[sa].forEach((curr, i) => {
        const key = `${sa}_${curr.weekStart}`;
        sourceAppWoW[key] = { spendChangePercent: 0, eProfitChangePercent: 0, growthStatus: 'First Week' };
        if (i > 0) {
          const prev = sourceApps[sa][i - 1];
          const spendPct = prev.spend ? ((curr.spend - prev.spend) / Math.abs(prev.spend)) * 100 : 0;
          const profitPct = prev.eProfitForecast ? ((curr.eProfitForecast - prev.eProfitForecast) / Math.abs(prev.eProfitForecast)) * 100 : 0;
          let status = '⚪ Stable';
          if (prev.eProfitForecast < 0 && curr.eProfitForecast > 0) status = '🟢 Healthy Growth';
          else if (prev.eProfitForecast > 0 && curr.eProfitForecast < 0) status = '🔴 Inefficient Growth';
          else if (spendPct > 10 && profitPct > 5) status = '🟢 Healthy Growth';
          else if (spendPct > 10 && profitPct < -5) status = '🔴 Inefficient Growth';
          else if (spendPct > 0 && profitPct > 0) status = '🟡 Moderate Growth';
          else if (spendPct < -10) status = '🔵 Scaling Down';
          sourceAppWoW[key] = { spendChangePercent: spendPct, eProfitChangePercent: profitPct, growthStatus: status };
        }
      });
    });

    // Compute app-level WoW
    const appWeekWoW = {};
    Object.keys(appWeekData).forEach(appName => {
      const weeks = Object.values(appWeekData[appName]).sort((a, b) => new Date(a.weekStart) - new Date(b.weekStart));
      weeks.forEach((curr, i) => {
        const key = `${appName}_${curr.weekStart}`;
        appWeekWoW[key] = { spendChangePercent: 0, eProfitChangePercent: 0, growthStatus: 'First Week' };
        if (i > 0) {
          const prev = weeks[i - 1];
          const spendPct = prev.spend ? ((curr.spend - prev.spend) / Math.abs(prev.spend)) * 100 : 0;
          const profitPct = prev.profit ? ((curr.profit - prev.profit) / Math.abs(prev.profit)) * 100 : 0;
          let status = '⚪ Stable';
          if (prev.profit < 0 && curr.profit > 0) status = '🟢 Healthy Growth';
          else if (prev.profit > 0 && curr.profit < 0) status = '🔴 Inefficient Growth';
          else if (spendPct > 10 && profitPct > 5) status = '🟢 Healthy Growth';
          else if (spendPct > 10 && profitPct < -5) status = '🔴 Inefficient Growth';
          else if (spendPct > 0 && profitPct > 0) status = '🟡 Moderate Growth';
          else if (spendPct < -10) status = '🔵 Scaling Down';
          appWeekWoW[key] = { spendChangePercent: spendPct, eProfitChangePercent: profitPct, growthStatus: status };
        }
      });
    });

    return { sourceAppWoW, appWeekWoW };
  } catch (error) {
    console.error('Error calculating WoW metrics:', error);
    return { sourceAppWoW: {}, appWeekWoW: {} };
  }
}

/**
 * Create enhanced pivot table with week-level WoW analysis
 */
function createEnhancedPivotTable(appData) {
  const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
  let sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
  if (!sheet) sheet = spreadsheet.insertSheet(CONFIG.SHEET_NAME);
  else sheet.clear();

  const wow = calculateWoWMetrics(appData);

  const headers = [
    'Level', 'Week Range / Source App', 'ID', 'GEO',
    'Spend', 'Spend WoW %', 'Installs', 'CPI', 'ROAS D-1', 'IPM',
    'E-ARPU 365d', 'E-ROAS 365d', 'E-Profit 730d', 'eProfit WoW %', 'Growth Status', 'Comments'
  ];
  const tableData = [headers];
  const formatData = [];

  const appKeys = Object.keys(appData).sort((a, b) => appData[a].appName.localeCompare(appData[b].appName));
  appKeys.forEach(appKey => {
    const app = appData[appKey];
    // APP row
    formatData.push({ row: tableData.length + 1, type: 'APP' });
    tableData.push(['APP', app.appName, '', '', '', '', '', '', '', '', '', '', '', '', '', '']);

    const weekKeys = Object.keys(app.weeks).sort();
    weekKeys.forEach(weekKey => {
      const week = app.weeks[weekKey];
      const campaigns = week.campaigns;
      const totalSpend = campaigns.reduce((s, c) => s + c.spend, 0);
      const totalInstalls = campaigns.reduce((s, c) => s + c.installs, 0);
      const avgCpi = totalInstalls ? totalSpend / totalInstalls : 0;
      const avgRoas = campaigns.length ? campaigns.reduce((s, c) => s + c.roas, 0) / campaigns.length : 0;
      const avgIpm = campaigns.length ? campaigns.reduce((s, c) => s + c.ipm, 0) / campaigns.length : 0;
      const avgArpu = campaigns.length ? campaigns.reduce((s, c) => s + c.eArpuForecast, 0) / campaigns.length : 0;
      const reliable = campaigns.filter(c => c.eRoasForecast >= 1 && c.eRoasForecast <= 1000 && c.installs >= 10 && c.spend > 0);
      const avgERoas = reliable.length ? reliable.reduce((s, c) => s + c.eRoasForecast, 0) / reliable.length : 0;
      const totalProfit = campaigns.reduce((s, c) => s + c.eProfitForecast, 0);
      // WEEK row
      const appWeekKey = `${app.appName}_${weekKey}`;
      const w = wow.appWeekWoW[appWeekKey] || {};
      const spendWoW = w.spendChangePercent ? `${w.spendChangePercent.toFixed(0)}%` : '';
      const profitWoW = w.eProfitChangePercent ? `${w.eProfitChangePercent.toFixed(0)}%` : '';
      const status = w.growthStatus || '';
      formatData.push({ row: tableData.length + 1, type: 'WEEK' });
      tableData.push([
        'WEEK',
        `${week.weekStart} - ${week.weekEnd}`,
        '', '',
        totalSpend.toFixed(2),
        spendWoW,
        totalInstalls,
        avgCpi.toFixed(3),
        avgRoas.toFixed(2),
        avgIpm.toFixed(1),
        avgArpu.toFixed(3),
        `${avgERoas.toFixed(0)}%`,
        totalProfit.toFixed(2),
        profitWoW,
        status,
        '' // Comments column
      ]);
      // CAMPAIGN rows
      campaigns.sort((a, b) => b.spend - a.spend).forEach(c => {
        const link = `=HYPERLINK("https://app.appgrowth.com/campaigns/${c.campaignId}", "${c.campaignId}")`;
        const key = `${c.sourceApp}_${weekKey}`;
        const sc = wow.sourceAppWoW[key] || {};
        const sPct = sc.spendChangePercent ? `${sc.spendChangePercent.toFixed(0)}%` : '';
        const pPct = sc.eProfitChangePercent ? `${sc.eProfitChangePercent.toFixed(0)}%` : '';
        const gStat = sc.growthStatus || '';
        tableData.push([
          'CAMPAIGN',
          c.sourceApp,
          link,
          c.geo,
          c.spend.toFixed(2),
          sPct,
          c.installs,
          c.cpi ? c.cpi.toFixed(3) : '0.000',
          c.roas.toFixed(2),
          c.ipm.toFixed(1),
          c.eArpuForecast.toFixed(3),
          `${c.eRoasForecast.toFixed(0)}%`,
          c.eProfitForecast.toFixed(2),
          pPct,
          gStat,
          '' // Comments column
        ]);
      });
    });
  });

  // Write data
  const range = sheet.getRange(1, 1, tableData.length, headers.length);
  range.setValues(tableData);
  // Formatting and grouping
  applyEnhancedFormatting(sheet, tableData.length, headers.length, formatData);
  createRowGrouping(sheet, tableData, appData);
  sheet.setFrozenRows(1);
}

/**
 * Enhanced formatting function using batch operations
 */
function applyEnhancedFormatting(sheet, numRows, numCols, formatData) {
  // Header
  sheet.getRange(1, 1, 1, numCols)
       .setBackground('#4285f4').setFontColor('white')
       .setFontWeight('bold').setHorizontalAlignment('center')
       .setFontSize(11);

  // Column widths - updated to include Comments column
  const widths = [
    {c:1,w:80},{c:2,w:300},{c:3,w:50},{c:4,w:50},{c:5,w:75},
    {c:6,w:150},{c:7,w:75},{c:8,w:75},{c:9,w:75},{c:10,w:75},
    {c:11,w:100},{c:12,w:120},{c:13,w:125},{c:14,w:125},{c:15,w:150},{c:16,w:200}
  ];
  widths.forEach(col => sheet.setColumnWidth(col.c, col.w));

  const appRows = [], weekRows = [];
  formatData.forEach(item => {
    if (item.type==='APP') appRows.push(item.row);
    if (item.type==='WEEK') weekRows.push(item.row);
  });
  const campaignRows = [];
  for (let r=2; r<=numRows; r++) {
    if (!appRows.includes(r) && !weekRows.includes(r)) campaignRows.push(r);
  }
  // APP rows
  appRows.forEach(r =>
    sheet.getRange(r,1,1,numCols)
         .setBackground('#d1e7fe').setFontColor('black')
         .setFontWeight('bold').setFontSize(11)
  );
  // WEEK rows
  weekRows.forEach(r =>
    sheet.getRange(r,1,1,numCols)
         .setBackground('#e8f0fe').setFontSize(11)
  );
  // CAMPAIGN rows
  campaignRows.forEach(r =>
    sheet.getRange(r,1,1,numCols)
         .setBackground('#ffffff').setFontSize(10)
  );
  // Numeric formats
  if (numRows>1) {
    sheet.getRange(2,5,numRows-1,1).setNumberFormat('$0.00');
    sheet.getRange(2,8,numRows-1,1).setNumberFormat('$0.000');
    sheet.getRange(2,9,numRows-1,1).setNumberFormat('0.00');
    sheet.getRange(2,10,numRows-1,1).setNumberFormat('0.0');
    sheet.getRange(2,11,numRows-1,1).setNumberFormat('$0.000');
    sheet.getRange(2,13,numRows-1,1).setNumberFormat('$0.00');
  }
  applyConditionalFormatting(sheet, numRows);
  sheet.hideColumns(1);
}

/**
 * Enhanced conditional formatting with color gradients
 */
function applyConditionalFormatting(sheet, numRows) {
  const rules = [];
  if (numRows>1) {
    // Spend WoW %
    const sRange = sheet.getRange(2,6,numRows-1,1);
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenTextContains('%').whenNumberGreaterThan(0)
        .setBackground('#d1f2eb').setFontColor('#0c5460')
        .setRanges([sRange]).build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenTextContains('%').whenNumberLessThan(0)
        .setBackground('#f8d7da').setFontColor('#721c24')
        .setRanges([sRange]).build()
    );
    // E-ROAS 365d
    const eRange = sheet.getRange(2,12,numRows-1,1);
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied('=AND(NOT(ISBLANK(L2)), VALUE(SUBSTITUTE(L2,"%","")) >= '+CONFIG.TARGET_EROAS+')')
        .setBackground('#d1f2eb').setFontColor('#0c5460')
        .setRanges([eRange]).build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied('=AND(NOT(ISBLANK(L2)), VALUE(SUBSTITUTE(L2,"%","")) >= 120, VALUE(SUBSTITUTE(L2,"%","")) < '+CONFIG.TARGET_EROAS+')')
        .setBackground('#fff3cd').setFontColor('#856404')
        .setRanges([eRange]).build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenFormulaSatisfied('=AND(NOT(ISBLANK(L2)), VALUE(SUBSTITUTE(L2,"%","")) < 120)')
        .setBackground('#f8d7da').setFontColor('#721c24')
        .setRanges([eRange]).build()
    );
    // eProfit WoW %
    const pRange = sheet.getRange(2,14,numRows-1,1);
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenTextContains('%').whenNumberGreaterThan(0)
        .setBackground('#d1f2eb').setFontColor('#0c5460')
        .setRanges([pRange]).build()
    );
    rules.push(
      SpreadsheetApp.newConditionalFormatRule()
        .whenTextContains('%').whenNumberLessThan(0)
        .setBackground('#f8d7da').setFontColor('#721c24')
        .setRanges([pRange]).build()
    );
    // Growth Status
    const gRange = sheet.getRange(2,15,numRows-1,1);
    ['🟢 Healthy Growth','🔴 Inefficient Growth','🟡 Moderate Growth','🔵 Scaling Down'].forEach(status => {
      let bg = '#fff';
      let fc = '#000';
      if (status.includes('🟢')) { bg='#d1f2eb'; fc='#0c5460'; }
      if (status.includes('🔴')) { bg='#f5c6cb'; fc='#721c24'; }
      if (status.includes('🟡')) { bg='#fff3cd'; fc='#856404'; }
      if (status.includes('🔵')) { bg='#d1ecf1'; fc='#0c5460'; }
      rules.push(
        SpreadsheetApp.newConditionalFormatRule()
          .whenTextContains(status)
          .setBackground(bg).setFontColor(fc)
          .setRanges([gRange]).build()
      );
    });
  }
  sheet.setConditionalFormatRules(rules);
}

/**
 * Исправленная функция группировки: App → Week → Campaign
 */
function createRowGrouping(sheet, tableData, appData) {
  var rowPointer = 2;   // начинаем со второй строки (первая — заголовки)
  var numCols = 16; // Updated to include Comments column

  // Если appData не передан, используем данные из таблицы
  if (!appData) {
    // Парсим структуру из tableData
    var currentApp = null;
    var appStartRow = null;
    var weekStartRow = null;
    var appGroups = [];
    var weekGroups = [];
    
    for (var i = 1; i < tableData.length; i++) {
      var row = tableData[i];
      var level = row[0];
      
      if (level === 'APP') {
        // Закрываем предыдущую неделю, если есть
        if (weekStartRow !== null && i > weekStartRow + 1) {
          weekGroups.push({start: weekStartRow + 1, count: i - weekStartRow - 1});
        }
        // Закрываем предыдущее приложение, если есть
        if (appStartRow !== null && i > appStartRow + 1) {
          appGroups.push({start: appStartRow + 1, count: i - appStartRow - 1});
        }
        
        currentApp = row[1];
        appStartRow = i;
        weekStartRow = null;
      } else if (level === 'WEEK') {
        // Закрываем предыдущую неделю, если есть
        if (weekStartRow !== null && i > weekStartRow + 1) {
          weekGroups.push({start: weekStartRow + 1, count: i - weekStartRow - 1});
        }
        weekStartRow = i;
      }
    }
    
    // Закрываем последнюю неделю
    if (weekStartRow !== null && tableData.length > weekStartRow + 1) {
      weekGroups.push({start: weekStartRow + 1, count: tableData.length - weekStartRow - 1});
    }
    // Закрываем последнее приложение
    if (appStartRow !== null && tableData.length > appStartRow + 1) {
      appGroups.push({start: appStartRow + 1, count: tableData.length - appStartRow - 1});
    }
    
    // Применяем группировку
    // Сначала группируем недели (более глубокий уровень)
    weekGroups.forEach(function(group) {
      try {
        sheet.getRange(group.start, 1, group.count, numCols).shiftRowGroupDepth(1);
        sheet.getRange(group.start, 1, group.count, 1).collapseGroups();
      } catch (e) {
        // игнорируем ошибки
      }
    });
    
    // Затем группируем приложения
    appGroups.forEach(function(group) {
      try {
        sheet.getRange(group.start, 1, group.count, numCols).shiftRowGroupDepth(1);
        sheet.getRange(group.start, 1, group.count, 1).collapseGroups();
      } catch (e) {
        // игнорируем ошибки
      }
    });
    
    return;
  }

  // Исходная логика, если appData передан
  // Сортируем ключи apps по названию
  var sortedApps = Object.keys(appData).sort(function(a, b) {
    return appData[a].appName.localeCompare(appData[b].appName);
  });

  sortedApps.forEach(function(appKey) {
    var app = appData[appKey];
    var appRow = rowPointer;  // строка с "APP"
    rowPointer++;             // переходим к первой "WEEK" этого app

    // Проходим по всем неделям внутри app
    var sortedWeeks = Object.keys(app.weeks).sort();
    sortedWeeks.forEach(function(weekKey) {
      var week = app.weeks[weekKey];
      var weekRow = rowPointer;  // строка с "WEEK"
      rowPointer++;              // займём эту строку

      var cnt = week.campaigns.length;
      if (cnt > 0) {
        try {
          // Группируем кампании под этой неделей
          sheet.getRange(weekRow + 1, 1, cnt, numCols)
               .shiftRowGroupDepth(1);
          sheet.getRange(weekRow + 1, 1, cnt, 1)
               .collapseGroups();
        } catch (e) {
          // игнорируем ошибки сгруппирования
        }
        rowPointer += cnt;  // пропускаем все CAMPAIGN-строки
      }
    });

    // Теперь сгруппируем все WEEK+CAMPAIGN внутри app
    var totalRowsInApp = rowPointer - appRow - 1; // -1 чтобы не включать саму строку APP
    if (totalRowsInApp > 0) {
      try {
        sheet.getRange(appRow + 1, 1, totalRowsInApp, numCols)
             .shiftRowGroupDepth(1);
        sheet.getRange(appRow + 1, 1, totalRowsInApp, 1)
             .collapseGroups();
      } catch (e) {
        // игнорируем ошибки сгруппирования
      }
    }
  });
}
