/**
 * Comment Cache Management
 * Handles saving and loading comments from a hidden sheet
 * Includes automatic caching functionality with 15-minute intervals
 */
class CommentCache {
  constructor() {
    this.cacheSheet = this.getOrCreateCacheSheet();
  }

  /**
   * Get or create the comments cache sheet
   */
  getOrCreateCacheSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    let sheet = spreadsheet.getSheetByName(CONFIG.COMMENTS_CACHE_SHEET);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(CONFIG.COMMENTS_CACHE_SHEET);
      sheet.hideSheet();
      // Headers: AppName, WeekRange, Comment, LastUpdated
      sheet.getRange(1, 1, 1, 4).setValues([['AppName', 'WeekRange', 'Comment', 'LastUpdated']]);
    }
    return sheet;
  }

  /**
   * Generate a unique key for app-week combination
   */
  getCommentKey(appName, weekRange) {
    return `${appName}|||${weekRange}`;
  }

  /**
   * Load all comments from cache sheet
   */
  loadAllComments() {
    const comments = {};
    const data = this.cacheSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      const [appName, weekRange, comment, lastUpdated] = data[i];
      if (comment) {
        const key = this.getCommentKey(appName, weekRange);
        comments[key] = comment;
      }
    }
    return comments;
  }

  /**
   * Save a comment to cache
   */
  saveComment(appName, weekRange, comment) {
    if (!comment || !comment.trim()) return;
    
    const data = this.cacheSheet.getDataRange().getValues();
    let found = false;
    
    // Update existing or add new
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === appName && data[i][1] === weekRange) {
        // Only update if new comment is longer (appending text)
        const existingComment = data[i][2] || '';
        if (comment.length > existingComment.length) {
          this.cacheSheet.getRange(i + 1, 3, 1, 2).setValues([[comment, new Date()]]);
        }
        found = true;
        break;
      }
    }
    
    if (!found) {
      const lastRow = this.cacheSheet.getLastRow();
      this.cacheSheet.getRange(lastRow + 1, 1, 1, 4).setValues([[appName, weekRange, comment, new Date()]]);
    }
  }

  /**
   * Sync comments from the main sheet to cache
   */
  syncCommentsFromSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // Expand all groups to ensure we can read all data
    expandAllGroups(sheet);
    
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }

  /**
   * Apply cached comments back to the main sheet
   */
  applyCommentsToSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    const comments = this.loadAllComments();
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp) {
        const key = this.getCommentKey(currentApp, nameOrRange);
        const comment = comments[key];
        if (comment) {
          sheet.getRange(i + 1, 16).setValue(comment); // Comments column
        }
      }
    }
  }

  /**
   * Sync comments from the main sheet to cache (quiet version without expanding groups)
   * Used by auto-cache to avoid interfering with user's group state
   */
  syncCommentsFromSheetQuiet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // DON'T expand groups - assume they're already expanded by caller
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }
}

/**
 * AUTO CACHE SYSTEM
 * Автоматическое кеширование комментариев каждые 15 минут
 */

/**
 * Автоматическое кеширование комментариев (без UI)
 * Запускается триггером каждые 15 минут
 * После кеширования сворачивает все группы
 */
function autoCacheComments() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    // Проверяем есть ли данные в таблице
    if (!sheet || sheet.getLastRow() < 2) {
      console.log('AutoCache: Нет данных для кеширования');
      return;
    }
    
    console.log('AutoCache: Начинаем кеширование...');
    
    // Разворачиваем все группы для чтения данных
    expandAllGroups(sheet);
    SpreadsheetApp.flush();
    
    // Синхронизируем комментарии
    const cache = new CommentCache();
    cache.syncCommentsFromSheetQuiet();
    
    console.log('AutoCache: Комментарии синхронизированы, сворачиваем группы...');
    
    // Сворачиваем все группы обратно - пробуем несколько методов
    forceCollapseAllGroups(sheet);
    
    console.log('AutoCache: Комментарии успешно кешированы - ' + new Date().toLocaleString());
    
  } catch (error) {
    console.error('AutoCache Error:', error);
    // Не показываем alert так как это автоматическая функция
  }
}

/**
 * Запустить автоматическое кеширование комментариев
 * Создает триггер на выполнение каждые 15 минут
 */
function startAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Проверяем, не установлен ли уже триггер
    const existingTriggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (existingTriggers.length > 0) {
      ui.alert(
        'Автокеширование уже активно', 
        'Автоматическое кеширование комментариев уже запущено.\n\n' +
        'Комментарии сохраняются каждые 15 минут автоматически.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Создаем новый триггер
    ScriptApp.newTrigger('autoCacheComments')
      .timeBased()
      .everyMinutes(15)
      .create();
    
    // Сразу выполняем первое кеширование
    autoCacheComments();
    
    ui.alert(
      'Автокеширование запущено', 
      'Автоматическое сохранение комментариев активировано!\n\n' +
      '• Комментарии будут сохраняться каждые 15 минут\n' +
      '• Первое сохранение выполнено сейчас\n' +
      '• Все группы сворачиваются после кеширования\n' +
      '• Для отключения используйте "Остановить автокеширование"',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка запуска автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось запустить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Остановить автоматическое кеширование комментариев
 * Удаляет все триггеры автокеширования
 */
function stopAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Находим и удаляем все триггеры автокеширования
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Автокеширование не активно', 
        'Автоматическое кеширование комментариев не запущено.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Подтверждение остановки
    const response = ui.alert(
      'Остановить автокеширование?',
      'Вы уверены, что хотите остановить автоматическое сохранение комментариев?\n\n' +
      'После остановки комментарии нужно будет сохранять вручную.',
      ui.ButtonSet.YES_NO
    );
    
    if (response !== ui.Button.YES) {
      return;
    }
    
    // Удаляем все триггеры
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    ui.alert(
      'Автокеширование остановлено', 
      `Автоматическое сохранение комментариев отключено.\n\n` +
      `Удалено триггеров: ${triggers.length}\n\n` +
      'Теперь комментарии нужно сохранять вручную через меню.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка остановки автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось остановить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Проверить статус автокеширования
 * Показывает информацию о состоянии триггеров
 */
function checkAutoCacheStatus() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Статус автокеширования',
        '❌ Автоматическое кеширование ОТКЛЮЧЕНО\n\n' +
        'Комментарии нужно сохранять вручную через меню.\n\n' +
        'Для включения используйте "Запустить автокеширование".',
        ui.ButtonSet.OK
      );
    } else {
      const trigger = triggers[0];
      const lastRun = getLastTriggerRun(trigger);
      const nextRun = getNextTriggerRun();
      
      ui.alert(
        'Статус автокеширования',
        '✅ Автоматическое кеширование АКТИВНО\n\n' +
        `• Интервал: каждые 15 минут\n` +
        `• Активных триггеров: ${triggers.length}\n` +
        `• Последний запуск: ${lastRun}\n` +
        `• Следующий запуск: ~${nextRun}\n` +
        `• Группы: полностью сворачиваются после кеширования\n\n` +
        'Комментарии сохраняются автоматически.',
        ui.ButtonSet.OK
      );
    }
    
  } catch (error) {
    console.error('Ошибка проверки статуса:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось проверить статус автокеширования:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Принудительно выполнить кеширование сейчас
 * Ручной запуск функции автокеширования
 */
function forceCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Используем ту же логику что и автокеширование
    autoCacheComments();
    ui.alert(
      'Кеширование выполнено',
      'Комментарии успешно сохранены в кеш.\n\n' +
      'Время выполнения: ' + new Date().toLocaleString() + '\n\n' +
      'Все группы свернуты для удобства.',
      ui.ButtonSet.OK
    );
  } catch (error) {
    ui.alert(
      'Ошибка кеширования',
      'Не удалось выполнить кеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Очистить все триггеры автокеширования (служебная функция)
 * Используется для полной очистки в случае проблем
 */
function clearAllAutoCacheTriggers() {
  const ui = SpreadsheetApp.getUi();
  
  const response = ui.alert(
    'ВНИМАНИЕ: Очистка всех триггеров',
    'Эта функция удалит ВСЕ триггеры автокеширования.\n\n' +
    'Используйте только в случае проблем с триггерами.\n\n' +
    'Продолжить?',
    ui.ButtonSet.YES_NO
  );
  
  if (response !== ui.Button.YES) {
    return;
  }
  
  try {
    const allTriggers = ScriptApp.getProjectTriggers();
    let deletedCount = 0;
    
    allTriggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === 'autoCacheComments') {
        ScriptApp.deleteTrigger(trigger);
        deletedCount++;
      }
    });
    
    ui.alert(
      'Триггеры очищены',
      `Удалено триггеров автокеширования: ${deletedCount}\n\n` +
      'Теперь можно заново запустить автокеширование.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    ui.alert(
      'Ошибка',
      'Не удалось очистить триггеры:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * GROUP MANAGEMENT
 * Простое управление группами - сворачивание от глубоких уровней к верхним
 */

/**
 * Свернуть все группы в листе (от вложенных к внешним)
 * Сначала CAMPAIGN, потом WEEK, потом APP
 */
function collapseAllGroups(sheet) {
  try {
    console.log('Начинаем сворачивание всех групп (от вложенных к внешним)...');
    
    // Анализируем структуру данных для правильного сворачивания
    const data = sheet.getDataRange().getValues();
    
    // Этап 1: Сворачиваем кампании внутри недель (самый глубокий уровень)
    collapseGroupsByLevel(sheet, data, 'CAMPAIGN');
    
    // Этап 2: Сворачиваем недели внутри приложений (средний уровень)  
    collapseGroupsByLevel(sheet, data, 'WEEK');
    
    // Этап 3: Сворачиваем приложения (верхний уровень)
    collapseGroupsByLevel(sheet, data, 'APP');
    
    console.log('Сворачивание всех уровней завершено');
    
  } catch (error) {
    console.error('Error collapsing groups:', error);
    
    // Если структурный подход не работает, пробуем универсальный
    try {
      console.log('Пробуем универсальный подход...');
      collapseGroupsUniversal(sheet);
    } catch (altError) {
      console.error('Universal approach failed:', altError);
    }
  }
}

/**
 * Свернуть группы определенного уровня
 */
function collapseGroupsByLevel(sheet, data, targetLevel) {
  try {
    console.log(`Сворачиваем группы уровня: ${targetLevel}`);
    
    const ranges = [];
    let currentGroupStart = -1;
    let currentGroupLevel = '';
    let currentParent = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const name = data[i][1];
      
      if (level === 'APP') {
        // Закрываем предыдущую группу если нужно
        if (currentGroupStart !== -1 && currentGroupLevel === targetLevel) {
          ranges.push(createGroupRange(currentGroupStart, i, currentGroupLevel, currentParent));
        }
        currentParent = name;
        currentGroupStart = -1;
        currentGroupLevel = '';
        
      } else if (level === 'WEEK') {
        // Закрываем предыдущую группу кампаний если нужно
        if (currentGroupStart !== -1 && currentGroupLevel === 'CAMPAIGN') {
          ranges.push(createGroupRange(currentGroupStart, i, currentGroupLevel, currentParent));
        }
        
        // Начинаем новую группу недели если это наш целевой уровень
        if (targetLevel === 'WEEK') {
          currentGroupStart = i + 1;
          currentGroupLevel = 'WEEK';
        } else {
          currentGroupStart = -1;
          currentGroupLevel = '';
        }
        
      } else if (level === 'CAMPAIGN') {
        // Начинаем группу кампаний если это наш целевой уровень
        if (targetLevel === 'CAMPAIGN' && currentGroupStart === -1) {
          currentGroupStart = i;
          currentGroupLevel = 'CAMPAIGN';
        }
      }
    }
    
    // Закрываем последнюю группу
    if (currentGroupStart !== -1 && currentGroupLevel === targetLevel) {
      ranges.push(createGroupRange(currentGroupStart, data.length, currentGroupLevel, currentParent));
    }
    
    // Сворачиваем найденные диапазоны
    ranges.forEach((range, index) => {
      try {
        if (range.size > 0) {
          console.log(`  Сворачиваем ${targetLevel} группу ${index + 1}: строки ${range.start}-${range.end} (размер: ${range.size})`);
          sheet.getRange(range.start, 1, range.size, 1).collapseGroups();
          SpreadsheetApp.flush();
        }
      } catch (e) {
        console.log(`  Ошибка сворачивания ${targetLevel} группы ${index + 1}: ${e.toString()}`);
      }
    });
    
    console.log(`Уровень ${targetLevel} обработан, найдено групп: ${ranges.length}`);
    
  } catch (error) {
    console.error(`Error collapsing ${targetLevel} level:`, error);
  }
}

/**
 * Создать объект диапазона группы
 */
function createGroupRange(start, end, level, parent) {
  return {
    start: start,
    end: end - 1,
    size: end - start,
    level: level,
    parent: parent
  };
}

/**
 * Универсальное сворачивание групп (запасной вариант)
 */
function collapseGroupsUniversal(sheet) {
  try {
    console.log('Универсальное сворачивание групп...');
    
    const lastRow = sheet.getLastRow();
    
    if (lastRow <= 1) {
      console.log('Нет данных для сворачивания');
      return;
    }
    
    // Попробуем несколько итераций сворачивания
    for (let iteration = 1; iteration <= 5; iteration++) {
      try {
        console.log(`Итерация ${iteration}...`);
        
        // Пробуем разные диапазоны
        const approaches = [
          () => sheet.getRange(1, 1, lastRow, 1).collapseGroups(),
          () => sheet.getRange(2, 1, lastRow - 1, 1).collapseGroups(),
          () => {
            // Построчно
            for (let row = lastRow; row >= 2; row--) {
              try {
                sheet.getRange(row, 1, 1, 1).collapseGroups();
              } catch (e) {
                // Игнорируем ошибки отдельных строк
              }
            }
          }
        ];
        
        let success = false;
        for (let i = 0; i < approaches.length; i++) {
          try {
            approaches[i]();
            SpreadsheetApp.flush();
            success = true;
            console.log(`  Подход ${i + 1} успешен`);
            break;
          } catch (e) {
            console.log(`  Подход ${i + 1} не сработал: ${e.toString()}`);
          }
        }
        
        if (!success) {
          console.log(`Итерация ${iteration} не дала результатов`);
          break;
        }
        
        Utilities.sleep(200); // Пауза между итерациями
        
      } catch (e) {
        console.log(`Итерация ${iteration} завершена: ${e.toString()}`);
        break;
      }
    }
    
    console.log('Универсальное сворачивание завершено');
    
  } catch (error) {
    console.error('Universal collapse failed:', error);
  }
}

/**
 * Принудительно свернуть все группы (комбинированный подход)
 */
function forceCollapseAllGroups(sheet) {
  try {
    console.log('=== ПРИНУДИТЕЛЬНОЕ СВОРАЧИВАНИЕ ВСЕХ ГРУПП ===');
    
    // Основной подход - структурное сворачивание
    console.log('1. Структурное сворачивание...');
    collapseAllGroups(sheet);
    
    Utilities.sleep(500);
    
    // Дополнительный подход - универсальное сворачивание
    console.log('2. Универсальное сворачивание...');
    collapseGroupsUniversal(sheet);
    
    Utilities.sleep(300);
    
    // Финальная проверка
    console.log('3. Финальная проверка...');
    try {
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        sheet.getRange(1, 1, lastRow, 1).collapseGroups();
        SpreadsheetApp.flush();
        console.log('Финальная попытка выполнена');
      }
    } catch (e) {
      console.log('Финальная попытка завершена: ' + e.toString());
    }
    
    console.log('=== ПРИНУДИТЕЛЬНОЕ СВОРАЧИВАНИЕ ЗАВЕРШЕНО ===');
    
  } catch (error) {
    console.error('Force collapse failed:', error);
  }
}

/**
 * Тестовая функция для проверки сворачивания групп
 * Можно запускать из меню для отладки
 */
function testCollapseGroups() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      ui.alert('Нет данных', 'В листе нет данных для тестирования групп.');
      return;
    }
    
    console.log('=== ТЕСТ СВОРАЧИВАНИЯ ГРУПП ===');
    
    // Сначала разворачиваем все группы
    console.log('1. Разворачиваем все группы...');
    expandAllGroups(sheet);
    SpreadsheetApp.flush();
    
    // Даем время на обновление
    Utilities.sleep(1000);
    
    // Теперь сворачиваем
    console.log('2. Сворачиваем группы...');
    forceCollapseAllGroups(sheet);
    
    ui.alert(
      'Тест завершен',
      'Тест сворачивания групп выполнен.\n\n' +
      'Проверьте консоль (Ctrl+Shift+I → Console) для подробностей.\n\n' +
      'Если группы не свернулись, возможно, в листе нет группировки или она настроена по-другому.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Test collapse error:', error);
    ui.alert(
      'Ошибка теста',
      'Ошибка при тестировании сворачивания групп:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Получить время последнего запуска триггера (примерное)
 */
function getLastTriggerRun(trigger) {
  try {
    // Google Apps Script не предоставляет точное время последнего запуска
    // Показываем примерную информацию
    return 'неизвестно (проверьте логи выполнения)';
  } catch (error) {
    return 'ошибка получения данных';
  }
}

/**
 * Получить примерное время следующего запуска
 */
function getNextTriggerRun() {
  try {
    const now = new Date();
    const next = new Date(now.getTime() + 15 * 60 * 1000); // +15 минут
    return next.toLocaleTimeString();
  } catch (error) {
    return 'неизвестно';
  }
}
