/**
 * Comment Cache Management
 * Handles saving and loading comments from a hidden sheet
 * Includes automatic caching functionality with 15-minute intervals
 */
class CommentCache {
  constructor() {
    this.cacheSheet = this.getOrCreateCacheSheet();
  }

  /**
   * Get or create the comments cache sheet
   */
  getOrCreateCacheSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    let sheet = spreadsheet.getSheetByName(CONFIG.COMMENTS_CACHE_SHEET);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(CONFIG.COMMENTS_CACHE_SHEET);
      sheet.hideSheet();
      // Headers: AppName, WeekRange, Comment, LastUpdated
      sheet.getRange(1, 1, 1, 4).setValues([['AppName', 'WeekRange', 'Comment', 'LastUpdated']]);
    }
    return sheet;
  }

  /**
   * Generate a unique key for app-week combination
   */
  getCommentKey(appName, weekRange) {
    return `${appName}|||${weekRange}`;
  }

  /**
   * Load all comments from cache sheet
   */
  loadAllComments() {
    const comments = {};
    const data = this.cacheSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      const [appName, weekRange, comment, lastUpdated] = data[i];
      if (comment) {
        const key = this.getCommentKey(appName, weekRange);
        comments[key] = comment;
      }
    }
    return comments;
  }

  /**
   * Save a comment to cache
   */
  saveComment(appName, weekRange, comment) {
    if (!comment || !comment.trim()) return;
    
    const data = this.cacheSheet.getDataRange().getValues();
    let found = false;
    
    // Update existing or add new
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === appName && data[i][1] === weekRange) {
        // Only update if new comment is longer (appending text)
        const existingComment = data[i][2] || '';
        if (comment.length > existingComment.length) {
          this.cacheSheet.getRange(i + 1, 3, 1, 2).setValues([[comment, new Date()]]);
        }
        found = true;
        break;
      }
    }
    
    if (!found) {
      const lastRow = this.cacheSheet.getLastRow();
      this.cacheSheet.getRange(lastRow + 1, 1, 1, 4).setValues([[appName, weekRange, comment, new Date()]]);
    }
  }

  /**
   * Sync comments from the main sheet to cache
   */
  syncCommentsFromSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // Expand all groups to ensure we can read all data
    expandAllGroups(sheet);
    
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }

  /**
   * Apply cached comments back to the main sheet
   */
  applyCommentsToSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    const comments = this.loadAllComments();
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp) {
        const key = this.getCommentKey(currentApp, nameOrRange);
        const comment = comments[key];
        if (comment) {
          sheet.getRange(i + 1, 16).setValue(comment); // Comments column
        }
      }
    }
  }

  /**
   * Sync comments from the main sheet to cache (quiet version without expanding groups)
   * Used by auto-cache to avoid interfering with user's group state
   */
  syncCommentsFromSheetQuiet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // DON'T expand groups - assume they're already expanded by caller
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }
}

/**
 * AUTO CACHE SYSTEM
 * Автоматическое кеширование комментариев каждые 15 минут
 */

/**
 * Автоматическое кеширование комментариев (без UI)
 * Запускается триггером каждые 15 минут
 * Сохраняет и восстанавливает состояние групп чтобы не мешать пользователю
 */
function autoCacheComments() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    // Проверяем есть ли данные в таблице
    if (!sheet || sheet.getLastRow() < 2) {
      console.log('AutoCache: Нет данных для кеширования');
      return;
    }
    
    // Проверяем настройку пользователя о восстановлении групп
    const userProperties = PropertiesService.getUserProperties();
    const shouldRestoreGroups = userProperties.getProperty('AUTO_CACHE_RESTORE_GROUPS') === 'true';
    
    let groupState = null;
    
    // Сохраняем текущее состояние групп если нужно восстанавливать
    if (shouldRestoreGroups) {
      groupState = saveGroupState(sheet);
    }
    
    // Разворачиваем все группы для чтения данных
    expandAllGroups(sheet);
    
    // Синхронизируем комментарии (без повторного разворачивания)
    const cache = new CommentCache();
    cache.syncCommentsFromSheetQuiet(); // Новый метод без expandAllGroups
    
    // Восстанавливаем состояние групп если настройка включена
    if (shouldRestoreGroups && groupState) {
      restoreGroupState(sheet, groupState);
    }
    
    console.log('AutoCache: Комментарии успешно кешированы - ' + new Date().toLocaleString());
    
  } catch (error) {
    console.error('AutoCache Error:', error);
    // Не показываем alert так как это автоматическая функция
  }
}

/**
 * Запустить автоматическое кеширование комментариев
 * Создает триггер на выполнение каждые 15 минут
 */
function startAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Проверяем, не установлен ли уже триггер
    const existingTriggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (existingTriggers.length > 0) {
      ui.alert(
        'Автокеширование уже активно', 
        'Автоматическое кеширование комментариев уже запущено.\n\n' +
        'Комментарии сохраняются каждые 15 минут автоматически.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Спрашиваем пользователя о настройках групп
    const groupResponse = ui.alert(
      'Настройка автокеширования',
      'Автокеширование должно временно разворачивать группы для доступа к данным.\n\n' +
      'Хотите ли вы, чтобы группы автоматически сворачивались обратно после кеширования?\n\n' +
      '• ДА - группы будут восстановлены (рекомендуется)\n' +
      '• НЕТ - группы останутся развернутыми',
      ui.ButtonSet.YES_NO
    );
    
    // Сохраняем настройку пользователя
    const userProperties = PropertiesService.getUserProperties();
    userProperties.setProperty('AUTO_CACHE_RESTORE_GROUPS', groupResponse === ui.Button.YES ? 'true' : 'false');
    
    // Создаем новый триггер
    ScriptApp.newTrigger('autoCacheComments')
      .timeBased()
      .everyMinutes(15)
      .create();
    
    // Сразу выполняем первое кеширование
    autoCacheComments();
    
    const groupSetting = groupResponse === ui.Button.YES ? 'восстанавливаются' : 'остаются развернутыми';
    
    ui.alert(
      'Автокеширование запущено', 
      'Автоматическое сохранение комментариев активировано!\n\n' +
      '• Комментарии будут сохраняться каждые 15 минут\n' +
      '• Первое сохранение выполнено сейчас\n' +
      `• Группы после кеширования: ${groupSetting}\n` +
      '• Для отключения используйте "Остановить автокеширование"',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка запуска автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось запустить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Остановить автоматическое кеширование комментариев
 * Удаляет все триггеры автокеширования
 */
function stopAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Находим и удаляем все триггеры автокеширования
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Автокеширование не активно', 
        'Автоматическое кеширование комментариев не запущено.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Подтверждение остановки
    const response = ui.alert(
      'Остановить автокеширование?',
      'Вы уверены, что хотите остановить автоматическое сохранение комментариев?\n\n' +
      'После остановки комментарии нужно будет сохранять вручную.',
      ui.ButtonSet.YES_NO
    );
    
    if (response !== ui.Button.YES) {
      return;
    }
    
    // Удаляем все триггеры
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    ui.alert(
      'Автокеширование остановлено', 
      `Автоматическое сохранение комментариев отключено.\n\n` +
      `Удалено триггеров: ${triggers.length}\n\n` +
      'Теперь комментарии нужно сохранять вручную через меню.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка остановки автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось остановить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Проверить статус автокеширования
 * Показывает информацию о состоянии триггеров
 */
function checkAutoCacheStatus() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Статус автокеширования',
        '❌ Автоматическое кеширование ОТКЛЮЧЕНО\n\n' +
        'Комментарии нужно сохранять вручную через меню.\n\n' +
        'Для включения используйте "Запустить автокеширование".',
        ui.ButtonSet.OK
      );
    } else {
      const trigger = triggers[0];
      const lastRun = getLastTriggerRun(trigger);
      const nextRun = getNextTriggerRun();
      
      // Проверяем настройку восстановления групп
      const userProperties = PropertiesService.getUserProperties();
      const restoreGroups = userProperties.getProperty('AUTO_CACHE_RESTORE_GROUPS') === 'true';
      const groupBehavior = restoreGroups ? 'восстанавливаются после кеширования' : 'остаются развернутыми';
      
      ui.alert(
        'Статус автокеширования',
        '✅ Автоматическое кеширование АКТИВНО\n\n' +
        `• Интервал: каждые 15 минут\n` +
        `• Активных триггеров: ${triggers.length}\n` +
        `• Последний запуск: ${lastRun}\n` +
        `• Следующий запуск: ~${nextRun}\n` +
        `• Группы: ${groupBehavior}\n\n` +
        'Комментарии сохраняются автоматически.',
        ui.ButtonSet.OK
      );
    }
    
  } catch (error) {
    console.error('Ошибка проверки статуса:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось проверить статус автокеширования:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Изменить настройки автокеширования
 * Позволяет изменить поведение с группами без перезапуска
 */
function configureAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Проверяем активность автокеширования
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Автокеширование не активно',
        'Сначала запустите автокеширование, а затем настройте его.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Получаем текущую настройку
    const userProperties = PropertiesService.getUserProperties();
    const currentSetting = userProperties.getProperty('AUTO_CACHE_RESTORE_GROUPS') === 'true';
    const currentText = currentSetting ? 'ДА (восстанавливаются)' : 'НЕТ (остаются развернутыми)';
    
    // Спрашиваем о новой настройке
    const response = ui.alert(
      'Настройки автокеширования',
      `Текущая настройка групп: ${currentText}\n\n` +
      'Автокеширование должно временно разворачивать группы для доступа к данным.\n\n' +
      'Хотите ли вы, чтобы группы автоматически сворачивались обратно после кеширования?\n\n' +
      '• ДА - группы будут восстановлены (рекомендуется)\n' +
      '• НЕТ - группы останутся развернутыми',
      ui.ButtonSet.YES_NO
    );
    
    // Сохраняем новую настройку
    const newSetting = response === ui.Button.YES;
    userProperties.setProperty('AUTO_CACHE_RESTORE_GROUPS', newSetting ? 'true' : 'false');
    
    const newText = newSetting ? 'будут восстанавливаться' : 'будут оставаться развернутыми';
    
    ui.alert(
      'Настройки обновлены',
      `Настройка изменена успешно!\n\n` +
      `Теперь группы ${newText} после автоматического кеширования.\n\n` +
      'Изменения вступят в силу при следующем автокешировании.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка настройки автокеширования:', error);
    ui.alert(
      'Ошибка',
      'Не удалось изменить настройки:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Получить время последнего запуска триггера (примерное)
 */
function getLastTriggerRun(trigger) {
  try {
    // Google Apps Script не предоставляет точное время последнего запуска
    // Показываем примерную информацию
    return 'неизвестно (проверьте логи выполнения)';
  } catch (error) {
    return 'ошибка получения данных';
  }
}

/**
 * Получить примерное время следующего запуска
 */
function getNextTriggerRun() {
  try {
    const now = new Date();
    const next = new Date(now.getTime() + 15 * 60 * 1000); // +15 минут
    return next.toLocaleTimeString();
  } catch (error) {
    return 'неизвестно';
  }
}

/**
 * Очистить все триггеры автокеширования (служебная функция)
 * Используется для полной очистки в случае проблем
 */
function clearAllAutoCacheTriggers() {
  const ui = SpreadsheetApp.getUi();
  
  const response = ui.alert(
    'ВНИМАНИЕ: Очистка всех триггеров',
    'Эта функция удалит ВСЕ триггеры автокеширования.\n\n' +
    'Используйте только в случае проблем с триггерами.\n\n' +
    'Продолжить?',
    ui.ButtonSet.YES_NO
  );
  
  if (response !== ui.Button.YES) {
    return;
  }
  
  try {
    const allTriggers = ScriptApp.getProjectTriggers();
    let deletedCount = 0;
    
    allTriggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === 'autoCacheComments') {
        ScriptApp.deleteTrigger(trigger);
        deletedCount++;
      }
    });
    
    ui.alert(
      'Триггеры очищены',
      `Удалено триггеров автокеширования: ${deletedCount}\n\n` +
      'Теперь можно заново запустить автокеширование.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    ui.alert(
      'Ошибка',
      'Не удалось очистить триггеры:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Принудительно выполнить кеширование сейчас
 * Ручной запуск функции автокеширования
 */
function forceCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Используем ту же логику что и автокеширование
    autoCacheComments();
    ui.alert(
      'Кеширование выполнено',
      'Комментарии успешно сохранены в кеш.\n\n' +
      'Время выполнения: ' + new Date().toLocaleString() + '\n\n' +
      'Примечание: Использованы те же настройки групп, что и для автокеширования.',
      ui.ButtonSet.OK
    );
  } catch (error) {
    ui.alert(
      'Ошибка кеширования',
      'Не удалось выполнить кеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * GROUP STATE MANAGEMENT
 * Функции для сохранения и восстановления состояния групп
 */

/**
 * Сохранить текущее состояние групп (какие свернуты, какие развернуты)
 */
function saveGroupState(sheet) {
  try {
    const groupState = {
      collapsedRanges: []
    };
    
    const maxRows = sheet.getMaxRows();
    
    // Проходим по всем строкам и определяем свернутые группы
    // К сожалению, Google Apps Script не предоставляет прямого API для проверки состояния групп
    // Поэтому используем workaround через попытку развернуть
    let currentRow = 1;
    while (currentRow <= maxRows) {
      try {
        // Пробуем найти группы, проверяя видимость строк
        const range = sheet.getRange(currentRow, 1, 1, 1);
        
        // Попробуем определить, является ли строка частью свернутой группы
        // Это сложно сделать точно с текущим API, поэтому используем упрощенный подход
        
        currentRow++;
      } catch (e) {
        currentRow++;
      }
    }
    
    // Упрощенное решение: просто запоминаем, что нужно будет свернуть все группы обратно
    groupState.shouldCollapseAll = true;
    
    return groupState;
    
  } catch (error) {
    console.error('Error saving group state:', error);
    return { collapsedRanges: [], shouldCollapseAll: false };
  }
}

/**
 * Восстановить состояние групп
 */
function restoreGroupState(sheet, groupState) {
  try {
    if (!groupState || !groupState.shouldCollapseAll) {
      return;
    }
    
    // Поскольку точное определение состояния групп сложно,
    // используем эвристику: сворачиваем все группы после автокеширования
    // Это предполагает, что пользователь обычно держит группы свернутыми
    
    // Получаем данные для определения структуры
    const data = sheet.getDataRange().getValues();
    
    // Находим все группы (APP и WEEK уровни) и сворачиваем их
    collapseAllGroupsIntelligently(sheet, data);
    
  } catch (error) {
    console.error('Error restoring group state:', error);
  }
}

/**
 * Умное сворачивание групп на основе структуры данных
 */
function collapseAllGroupsIntelligently(sheet, data) {
  try {
    // Сначала сворачиваем группы более глубокого уровня (WEEK уровень)
    let currentApp = '';
    let weekGroupStart = -1;
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      
      if (level === 'APP') {
        // Если была открыта группа недель, сворачиваем её
        if (weekGroupStart !== -1) {
          try {
            const groupSize = i - weekGroupStart;
            if (groupSize > 1) {
              sheet.getRange(weekGroupStart, 1, groupSize, 1).collapseGroups();
            }
          } catch (e) {
            // Игнорируем ошибки группировки
          }
        }
        
        currentApp = data[i][1];
        weekGroupStart = -1;
      } else if (level === 'WEEK') {
        if (weekGroupStart === -1) {
          weekGroupStart = i + 1; // Начинаем группу с следующей строки (CAMPAIGN)
        }
      }
    }
    
    // Сворачиваем последнюю группу недель если есть
    if (weekGroupStart !== -1) {
      try {
        const groupSize = data.length - weekGroupStart;
        if (groupSize > 0) {
          sheet.getRange(weekGroupStart, 1, groupSize, 1).collapseGroups();
        }
      } catch (e) {
        // Игнорируем ошибки группировки
      }
    }
    
    // Теперь сворачиваем группы уровня приложений
    let appGroupStart = -1;
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      
      if (level === 'APP') {
        // Если была открыта группа приложения, сворачиваем её
        if (appGroupStart !== -1) {
          try {
            const groupSize = i - appGroupStart;
            if (groupSize > 1) {
              sheet.getRange(appGroupStart, 1, groupSize, 1).collapseGroups();
            }
          } catch (e) {
            // Игнорируем ошибки группировки
          }
        }
        
        appGroupStart = i + 1; // Начинаем новую группу приложения
      }
    }
    
    // Сворачиваем последнюю группу приложения
    if (appGroupStart !== -1) {
      try {
        const groupSize = data.length - appGroupStart;
        if (groupSize > 0) {
          sheet.getRange(appGroupStart, 1, groupSize, 1).collapseGroups();
        }
      } catch (e) {
        // Игнорируем ошибки группировки
      }
    }
    
  } catch (error) {
    console.error('Error in intelligent group collapsing:', error);
  }
}
