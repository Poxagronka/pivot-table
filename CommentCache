/**
 * Comment Cache Management
 * Handles saving and loading comments from a hidden sheet
 * Includes automatic caching functionality with 15-minute intervals
 */
class CommentCache {
  constructor() {
    this.cacheSheet = this.getOrCreateCacheSheet();
  }

  /**
   * Get or create the comments cache sheet
   */
  getOrCreateCacheSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    let sheet = spreadsheet.getSheetByName(CONFIG.COMMENTS_CACHE_SHEET);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(CONFIG.COMMENTS_CACHE_SHEET);
      sheet.hideSheet();
      // Headers: AppName, WeekRange, Comment, LastUpdated
      sheet.getRange(1, 1, 1, 4).setValues([['AppName', 'WeekRange', 'Comment', 'LastUpdated']]);
    }
    return sheet;
  }

  /**
   * Generate a unique key for app-week combination
   */
  getCommentKey(appName, weekRange) {
    return `${appName}|||${weekRange}`;
  }

  /**
   * Load all comments from cache sheet
   */
  loadAllComments() {
    const comments = {};
    const data = this.cacheSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      const [appName, weekRange, comment, lastUpdated] = data[i];
      if (comment) {
        const key = this.getCommentKey(appName, weekRange);
        comments[key] = comment;
      }
    }
    return comments;
  }

  /**
   * Save a comment to cache
   */
  saveComment(appName, weekRange, comment) {
    if (!comment || !comment.trim()) return;
    
    const data = this.cacheSheet.getDataRange().getValues();
    let found = false;
    
    // Update existing or add new
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === appName && data[i][1] === weekRange) {
        // Only update if new comment is longer (appending text)
        const existingComment = data[i][2] || '';
        if (comment.length > existingComment.length) {
          this.cacheSheet.getRange(i + 1, 3, 1, 2).setValues([[comment, new Date()]]);
        }
        found = true;
        break;
      }
    }
    
    if (!found) {
      const lastRow = this.cacheSheet.getLastRow();
      this.cacheSheet.getRange(lastRow + 1, 1, 1, 4).setValues([[appName, weekRange, comment, new Date()]]);
    }
  }

  /**
   * Sync comments from the main sheet to cache
   */
  syncCommentsFromSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // Expand all groups to ensure we can read all data
    expandAllGroups(sheet);
    
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }

  /**
   * Apply cached comments back to the main sheet
   */
  applyCommentsToSheet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    const comments = this.loadAllComments();
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp) {
        const key = this.getCommentKey(currentApp, nameOrRange);
        const comment = comments[key];
        if (comment) {
          sheet.getRange(i + 1, 16).setValue(comment); // Comments column
        }
      }
    }
  }

  /**
   * Sync comments from the main sheet to cache (quiet version without expanding groups)
   * Used by auto-cache to avoid interfering with user's group state
   */
  syncCommentsFromSheetQuiet() {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    if (!sheet || sheet.getLastRow() < 2) return;
    
    // DON'T expand groups - assume they're already expanded by caller
    const data = sheet.getDataRange().getValues();
    let currentApp = '';
    
    for (let i = 1; i < data.length; i++) {
      const level = data[i][0];
      const nameOrRange = data[i][1];
      const comment = data[i][15]; // Comments column
      
      if (level === 'APP') {
        currentApp = nameOrRange;
      } else if (level === 'WEEK' && currentApp && comment) {
        this.saveComment(currentApp, nameOrRange, comment);
      }
    }
  }
}

/**
 * AUTO CACHE SYSTEM
 * Автоматическое кеширование комментариев каждые 15 минут
 */

/**
 * Автоматическое кеширование комментариев (без UI)
 * Запускается триггером каждые 15 минут
 * После кеширования сворачивает все группы
 */
function autoCacheComments() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    // Проверяем есть ли данные в таблице
    if (!sheet || sheet.getLastRow() < 2) {
      console.log('AutoCache: Нет данных для кеширования');
      return;
    }
    
    console.log('AutoCache: Начинаем кеширование...');
    
    // Разворачиваем все группы для чтения данных
    expandAllGroups(sheet);
    SpreadsheetApp.flush();
    
    // Синхронизируем комментарии
    const cache = new CommentCache();
    cache.syncCommentsFromSheetQuiet();
    
    console.log('AutoCache: Комментарии синхронизированы, сворачиваем группы...');
    
    // Сворачиваем все группы обратно - пробуем несколько методов
    forceCollapseAllGroups(sheet);
    
    console.log('AutoCache: Комментарии успешно кешированы - ' + new Date().toLocaleString());
    
  } catch (error) {
    console.error('AutoCache Error:', error);
    // Не показываем alert так как это автоматическая функция
  }
}

/**
 * Запустить автоматическое кеширование комментариев
 * Создает триггер на выполнение каждые 15 минут
 */
function startAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Проверяем, не установлен ли уже триггер
    const existingTriggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (existingTriggers.length > 0) {
      ui.alert(
        'Автокеширование уже активно', 
        'Автоматическое кеширование комментариев уже запущено.\n\n' +
        'Комментарии сохраняются каждые 15 минут автоматически.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Создаем новый триггер
    ScriptApp.newTrigger('autoCacheComments')
      .timeBased()
      .everyMinutes(15)
      .create();
    
    // Сразу выполняем первое кеширование
    autoCacheComments();
    
    ui.alert(
      'Автокеширование запущено', 
      'Автоматическое сохранение комментариев активировано!\n\n' +
      '• Комментарии будут сохраняться каждые 15 минут\n' +
      '• Первое сохранение выполнено сейчас\n' +
      '• Все группы сворачиваются после кеширования\n' +
      '• Для отключения используйте "Остановить автокеширование"',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка запуска автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось запустить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Остановить автоматическое кеширование комментариев
 * Удаляет все триггеры автокеширования
 */
function stopAutoCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Находим и удаляем все триггеры автокеширования
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Автокеширование не активно', 
        'Автоматическое кеширование комментариев не запущено.',
        ui.ButtonSet.OK
      );
      return;
    }
    
    // Подтверждение остановки
    const response = ui.alert(
      'Остановить автокеширование?',
      'Вы уверены, что хотите остановить автоматическое сохранение комментариев?\n\n' +
      'После остановки комментарии нужно будет сохранять вручную.',
      ui.ButtonSet.YES_NO
    );
    
    if (response !== ui.Button.YES) {
      return;
    }
    
    // Удаляем все триггеры
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    ui.alert(
      'Автокеширование остановлено', 
      `Автоматическое сохранение комментариев отключено.\n\n` +
      `Удалено триггеров: ${triggers.length}\n\n` +
      'Теперь комментарии нужно сохранять вручную через меню.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Ошибка остановки автокеширования:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось остановить автокеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Проверить статус автокеширования
 * Показывает информацию о состоянии триггеров
 */
function checkAutoCacheStatus() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const triggers = ScriptApp.getProjectTriggers().filter(trigger => 
      trigger.getHandlerFunction() === 'autoCacheComments'
    );
    
    if (triggers.length === 0) {
      ui.alert(
        'Статус автокеширования',
        '❌ Автоматическое кеширование ОТКЛЮЧЕНО\n\n' +
        'Комментарии нужно сохранять вручную через меню.\n\n' +
        'Для включения используйте "Запустить автокеширование".',
        ui.ButtonSet.OK
      );
    } else {
      const trigger = triggers[0];
      const lastRun = getLastTriggerRun(trigger);
      const nextRun = getNextTriggerRun();
      
      ui.alert(
        'Статус автокеширования',
        '✅ Автоматическое кеширование АКТИВНО\n\n' +
        `• Интервал: каждые 15 минут\n` +
        `• Активных триггеров: ${triggers.length}\n` +
        `• Последний запуск: ${lastRun}\n` +
        `• Следующий запуск: ~${nextRun}\n` +
        `• Группы: полностью сворачиваются после кеширования\n\n` +
        'Комментарии сохраняются автоматически.',
        ui.ButtonSet.OK
      );
    }
    
  } catch (error) {
    console.error('Ошибка проверки статуса:', error);
    ui.alert(
      'Ошибка', 
      'Не удалось проверить статус автокеширования:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Принудительно выполнить кеширование сейчас
 * Ручной запуск функции автокеширования
 */
function forceCache() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Используем ту же логику что и автокеширование
    autoCacheComments();
    ui.alert(
      'Кеширование выполнено',
      'Комментарии успешно сохранены в кеш.\n\n' +
      'Время выполнения: ' + new Date().toLocaleString() + '\n\n' +
      'Все группы свернуты для удобства.',
      ui.ButtonSet.OK
    );
  } catch (error) {
    ui.alert(
      'Ошибка кеширования',
      'Не удалось выполнить кеширование:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Очистить все триггеры автокеширования (служебная функция)
 * Используется для полной очистки в случае проблем
 */
function clearAllAutoCacheTriggers() {
  const ui = SpreadsheetApp.getUi();
  
  const response = ui.alert(
    'ВНИМАНИЕ: Очистка всех триггеров',
    'Эта функция удалит ВСЕ триггеры автокеширования.\n\n' +
    'Используйте только в случае проблем с триггерами.\n\n' +
    'Продолжить?',
    ui.ButtonSet.YES_NO
  );
  
  if (response !== ui.Button.YES) {
    return;
  }
  
  try {
    const allTriggers = ScriptApp.getProjectTriggers();
    let deletedCount = 0;
    
    allTriggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === 'autoCacheComments') {
        ScriptApp.deleteTrigger(trigger);
        deletedCount++;
      }
    });
    
    ui.alert(
      'Триггеры очищены',
      `Удалено триггеров автокеширования: ${deletedCount}\n\n` +
      'Теперь можно заново запустить автокеширование.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    ui.alert(
      'Ошибка',
      'Не удалось очистить триггеры:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * GROUP MANAGEMENT
 * Простое управление группами
 */

/**
 * Свернуть все группы в листе (включая вложенные)
 */
function collapseAllGroups(sheet) {
  try {
    console.log('Начинаем сворачивание всех групп...');
    
    // Многократно сворачиваем группы до тех пор, пока все не будут свернуты
    const maxAttempts = 10; // Максимум попыток
    let attempt = 0;
    let hasMoreGroups = true;
    
    while (hasMoreGroups && attempt < maxAttempts) {
      attempt++;
      console.log(`Попытка сворачивания ${attempt}...`);
      
      try {
        const lastRow = sheet.getLastRow();
        const lastCol = sheet.getLastColumn();
        
        if (lastRow <= 1) {
          console.log('Нет данных для сворачивания');
          break;
        }
        
        // Попробуем свернуть все группы
        const range = sheet.getRange(1, 1, lastRow, lastCol);
        range.collapseGroups();
        
        SpreadsheetApp.flush();
        Utilities.sleep(100); // Небольшая пауза между попытками
        
        console.log(`Попытка ${attempt} выполнена`);
        
      } catch (e) {
        console.log(`Попытка ${attempt} завершена: ${e.toString()}`);
        hasMoreGroups = false; // Если ошибка, значит больше нет групп для сворачивания
      }
    }
    
    console.log(`Сворачивание завершено за ${attempt} попыток`);
    
  } catch (error) {
    console.error('Error collapsing groups:', error);
    
    // Если основной метод не работает, попробуем альтернативный
    try {
      console.log('Пробуем альтернативный подход...');
      collapseGroupsDeep(sheet);
    } catch (altError) {
      console.error('Alternative approach failed:', altError);
    }
  }
}

/**
 * Глубокое сворачивание групп - сворачиваем по уровням
 */
function collapseGroupsDeep(sheet) {
  try {
    console.log('Глубокое сворачивание групп...');
    
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    
    if (lastRow <= 1) {
      console.log('Нет данных для сворачивания');
      return;
    }
    
    // Попробуем разные диапазоны и стратегии
    const strategies = [
      // Стратегия 1: Полный диапазон, несколько попыток
      () => {
        console.log('Стратегия 1: Полный диапазон');
        for (let i = 0; i < 5; i++) {
          try {
            sheet.getRange(1, 1, lastRow, lastCol).collapseGroups();
            SpreadsheetApp.flush();
            console.log(`  Итерация ${i + 1} успешна`);
          } catch (e) {
            console.log(`  Итерация ${i + 1} завершена: ${e.toString()}`);
            break;
          }
        }
      },
      
      // Стратегия 2: Только первая колонка
      () => {
        console.log('Стратегия 2: Первая колонка');
        for (let i = 0; i < 5; i++) {
          try {
            sheet.getRange(1, 1, lastRow, 1).collapseGroups();
            SpreadsheetApp.flush();
            console.log(`  Итерация ${i + 1} успешна`);
          } catch (e) {
            console.log(`  Итерация ${i + 1} завершена: ${e.toString()}`);
            break;
          }
        }
      },
      
      // Стратегия 3: По блокам строк
      () => {
        console.log('Стратегия 3: По блокам строк');
        const blockSize = Math.max(10, Math.floor(lastRow / 10));
        for (let startRow = 2; startRow <= lastRow; startRow += blockSize) {
          const endRow = Math.min(startRow + blockSize - 1, lastRow);
          const rowCount = endRow - startRow + 1;
          
          try {
            sheet.getRange(startRow, 1, rowCount, 1).collapseGroups();
            console.log(`  Блок строк ${startRow}-${endRow} обработан`);
          } catch (e) {
            console.log(`  Блок строк ${startRow}-${endRow} пропущен: ${e.toString()}`);
          }
        }
        SpreadsheetApp.flush();
      }
    ];
    
    // Выполняем все стратегии
    strategies.forEach((strategy, index) => {
      try {
        strategy();
      } catch (e) {
        console.log(`Стратегия ${index + 1} не сработала: ${e.toString()}`);
      }
    });
    
    console.log('Глубокое сворачивание завершено');
    
  } catch (error) {
    console.error('Deep collapse failed:', error);
  }
}

/**
 * Принудительно свернуть все группы (самый агрессивный метод)
 */
function forceCollapseAllGroups(sheet) {
  try {
    console.log('Принудительное сворачивание всех групп...');
    
    // Сначала пробуем стандартный метод
    collapseAllGroups(sheet);
    
    // Затем дополнительно пробуем глубокое сворачивание
    Utilities.sleep(500); // Пауза между методами
    collapseGroupsDeep(sheet);
    
    // Финальная проверка - еще одна попытка стандартного метода
    Utilities.sleep(500);
    try {
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        sheet.getRange(1, 1, lastRow, 1).collapseGroups();
        SpreadsheetApp.flush();
        console.log('Финальная попытка сворачивания выполнена');
      }
    } catch (e) {
      console.log('Финальная попытка завершена: ' + e.toString());
    }
    
    console.log('Принудительное сворачивание завершено');
    
  } catch (error) {
    console.error('Force collapse failed:', error);
  }
}

/**
 * Тестовая функция для проверки сворачивания групп
 * Можно запускать из меню для отладки
 */
function testCollapseGroups() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheet = spreadsheet.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      ui.alert('Нет данных', 'В листе нет данных для тестирования групп.');
      return;
    }
    
    console.log('=== ТЕСТ СВОРАЧИВАНИЯ ГРУПП ===');
    
    // Сначала разворачиваем все группы
    console.log('1. Разворачиваем все группы...');
    expandAllGroups(sheet);
    SpreadsheetApp.flush();
    
    // Даем время на обновление
    Utilities.sleep(1000);
    
    // Теперь сворачиваем
    console.log('2. Сворачиваем группы...');
    forceCollapseAllGroups(sheet);
    
    ui.alert(
      'Тест завершен',
      'Тест сворачивания групп выполнен.\n\n' +
      'Проверьте консоль (Ctrl+Shift+I → Console) для подробностей.\n\n' +
      'Если группы не свернулись, возможно, в листе нет группировки или она настроена по-другому.',
      ui.ButtonSet.OK
    );
    
  } catch (error) {
    console.error('Test collapse error:', error);
    ui.alert(
      'Ошибка теста',
      'Ошибка при тестировании сворачивания групп:\n\n' + error.toString(),
      ui.ButtonSet.OK
    );
  }
}

/**
 * Получить время последнего запуска триггера (примерное)
 */
function getLastTriggerRun(trigger) {
  try {
    // Google Apps Script не предоставляет точное время последнего запуска
    // Показываем примерную информацию
    return 'неизвестно (проверьте логи выполнения)';
  } catch (error) {
    return 'ошибка получения данных';
  }
}

/**
 * Получить примерное время следующего запуска
 */
function getNextTriggerRun() {
  try {
    const now = new Date();
    const next = new Date(now.getTime() + 15 * 60 * 1000); // +15 минут
    return next.toLocaleTimeString();
  } catch (error) {
    return 'неизвестно';
  }
}
